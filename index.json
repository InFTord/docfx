{
  "api/Microsoft.DocAsCode.BuildOptions.html": {
    "href": "api/Microsoft.DocAsCode.BuildOptions.html",
    "title": "Class BuildOptions | docfx",
    "keywords": "Class BuildOptions Provides options to be used with Build(string, BuildOptions). Inheritance object BuildOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Microsoft.DocAsCode Assembly: Microsoft.DocAsCode.App.dll Syntax public class BuildOptions Properties | Improve this Doc View Source ConfigureMarkdig Configures the markdig markdown pipeline. Declaration public Func<MarkdownPipelineBuilder, MarkdownPipelineBuilder>? ConfigureMarkdig { get; init; } Property Value Type Description Func<MarkdownPipelineBuilder, MarkdownPipelineBuilder>"
  },
  "api/Microsoft.DocAsCode.DataContracts.ManagedReference.AdditionalNotes.html": {
    "href": "api/Microsoft.DocAsCode.DataContracts.ManagedReference.AdditionalNotes.html",
    "title": "Class AdditionalNotes | docfx",
    "keywords": "Class AdditionalNotes Inheritance object AdditionalNotes Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Microsoft.DocAsCode.DataContracts.ManagedReference Assembly: Microsoft.DocAsCode.Dotnet.dll Syntax [Serializable] public class AdditionalNotes Properties | Improve this Doc View Source Caller Declaration [JsonProperty(\"caller\")] [YamlMember(Alias = \"caller\")] public string Caller { get; set; } Property Value Type Description string | Improve this Doc View Source Implementer Declaration [JsonProperty(\"implementer\")] [YamlMember(Alias = \"implementer\")] public string Implementer { get; set; } Property Value Type Description string | Improve this Doc View Source Inheritor Declaration [JsonProperty(\"inheritor\")] [YamlMember(Alias = \"inheritor\")] public string Inheritor { get; set; } Property Value Type Description string"
  },
  "api/Microsoft.DocAsCode.DataContracts.ManagedReference.ApiParameter.html": {
    "href": "api/Microsoft.DocAsCode.DataContracts.ManagedReference.ApiParameter.html",
    "title": "Class ApiParameter | docfx",
    "keywords": "Class ApiParameter Inheritance object ApiParameter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Microsoft.DocAsCode.DataContracts.ManagedReference Assembly: Microsoft.DocAsCode.Dotnet.dll Syntax [Serializable] public class ApiParameter Properties | Improve this Doc View Source Attributes Declaration [YamlMember(Alias = \"attributes\")] [JsonProperty(\"attributes\")] [MergeOption(MergeOption.Ignore)] public List<AttributeInfo> Attributes { get; set; } Property Value Type Description List<AttributeInfo> | Improve this Doc View Source Description Declaration [YamlMember(Alias = \"description\")] [JsonProperty(\"description\")] public string Description { get; set; } Property Value Type Description string | Improve this Doc View Source Name Declaration [YamlMember(Alias = \"id\")] [JsonProperty(\"id\")] [MergeOption(MergeOption.MergeKey)] public string Name { get; set; } Property Value Type Description string | Improve this Doc View Source Type Declaration [YamlMember(Alias = \"type\")] [JsonProperty(\"type\")] public string Type { get; set; } Property Value Type Description string"
  },
  "api/Microsoft.DocAsCode.DataContracts.ManagedReference.ArgumentInfo.html": {
    "href": "api/Microsoft.DocAsCode.DataContracts.ManagedReference.ArgumentInfo.html",
    "title": "Class ArgumentInfo | docfx",
    "keywords": "Class ArgumentInfo Inheritance object ArgumentInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Microsoft.DocAsCode.DataContracts.ManagedReference Assembly: Microsoft.DocAsCode.Dotnet.dll Syntax [Serializable] public class ArgumentInfo Properties | Improve this Doc View Source Type Declaration [YamlMember(Alias = \"type\")] [JsonProperty(\"type\")] public string Type { get; set; } Property Value Type Description string | Improve this Doc View Source Value Declaration [YamlMember(Alias = \"value\")] [JsonProperty(\"value\")] public object Value { get; set; } Property Value Type Description object"
  },
  "api/Microsoft.DocAsCode.DataContracts.ManagedReference.AttributeInfo.html": {
    "href": "api/Microsoft.DocAsCode.DataContracts.ManagedReference.AttributeInfo.html",
    "title": "Class AttributeInfo | docfx",
    "keywords": "Class AttributeInfo Inheritance object AttributeInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Microsoft.DocAsCode.DataContracts.ManagedReference Assembly: Microsoft.DocAsCode.Dotnet.dll Syntax [Serializable] public class AttributeInfo Properties | Improve this Doc View Source Arguments Declaration [YamlMember(Alias = \"arguments\")] [JsonProperty(\"arguments\")] public List<ArgumentInfo> Arguments { get; set; } Property Value Type Description List<ArgumentInfo> | Improve this Doc View Source Constructor Declaration [YamlMember(Alias = \"ctor\")] [JsonProperty(\"ctor\")] public string Constructor { get; set; } Property Value Type Description string | Improve this Doc View Source NamedArguments Declaration [YamlMember(Alias = \"namedArguments\")] [JsonProperty(\"namedArguments\")] public List<NamedArgumentInfo> NamedArguments { get; set; } Property Value Type Description List<NamedArgumentInfo> | Improve this Doc View Source Type Declaration [YamlMember(Alias = \"type\")] [JsonProperty(\"type\")] public string Type { get; set; } Property Value Type Description string"
  },
  "api/Microsoft.DocAsCode.DataContracts.ManagedReference.ExceptionInfo.html": {
    "href": "api/Microsoft.DocAsCode.DataContracts.ManagedReference.ExceptionInfo.html",
    "title": "Class ExceptionInfo | docfx",
    "keywords": "Class ExceptionInfo Inheritance object ExceptionInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Microsoft.DocAsCode.DataContracts.ManagedReference Assembly: Microsoft.DocAsCode.Dotnet.dll Syntax [Serializable] public class ExceptionInfo Properties | Improve this Doc View Source CommentId Declaration [YamlMember(Alias = \"commentId\")] [JsonProperty(\"commentId\")] [MergeOption(MergeOption.Ignore)] public string CommentId { get; set; } Property Value Type Description string | Improve this Doc View Source Description Declaration [YamlMember(Alias = \"description\")] [JsonProperty(\"description\")] public string Description { get; set; } Property Value Type Description string | Improve this Doc View Source Type Declaration [YamlMember(Alias = \"type\")] [MergeOption(MergeOption.MergeKey)] [JsonProperty(\"type\")] public string Type { get; set; } Property Value Type Description string"
  },
  "api/Microsoft.DocAsCode.DataContracts.ManagedReference.html": {
    "href": "api/Microsoft.DocAsCode.DataContracts.ManagedReference.html",
    "title": "Namespace Microsoft.DocAsCode.DataContracts.ManagedReference | docfx",
    "keywords": "Namespace Microsoft.DocAsCode.DataContracts.ManagedReference Classes AdditionalNotes ApiParameter ArgumentInfo AttributeInfo ExceptionInfo ItemViewModel LinkInfo NamedArgumentInfo PageViewModel SyntaxDetailViewModel Enums LinkType MemberType SyntaxLanguage"
  },
  "api/Microsoft.DocAsCode.DataContracts.ManagedReference.ItemViewModel.html": {
    "href": "api/Microsoft.DocAsCode.DataContracts.ManagedReference.ItemViewModel.html",
    "title": "Class ItemViewModel | docfx",
    "keywords": "Class ItemViewModel Inheritance object ItemViewModel Implements Microsoft.DocAsCode.DataContracts.Common.IOverwriteDocumentViewModel Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Microsoft.DocAsCode.DataContracts.ManagedReference Assembly: Microsoft.DocAsCode.Dotnet.dll Syntax [Serializable] public class ItemViewModel : IOverwriteDocumentViewModel Properties | Improve this Doc View Source AdditionalNotes Declaration [YamlMember(Alias = \"additionalNotes\")] [JsonProperty(\"additionalNotes\")] public AdditionalNotes AdditionalNotes { get; set; } Property Value Type Description AdditionalNotes | Improve this Doc View Source AssemblyNameList Declaration [YamlMember(Alias = \"assemblies\")] [MergeOption(MergeOption.Ignore)] [JsonProperty(\"assemblies\")] public List<string> AssemblyNameList { get; set; } Property Value Type Description List<string> | Improve this Doc View Source Attributes Declaration [YamlMember(Alias = \"attributes\")] [JsonProperty(\"attributes\")] [MergeOption(MergeOption.Ignore)] public List<AttributeInfo> Attributes { get; set; } Property Value Type Description List<AttributeInfo> | Improve this Doc View Source Children Declaration [YamlMember(Alias = \"children\")] [MergeOption(MergeOption.Ignore)] [JsonProperty(\"children\")] public List<string> Children { get; set; } Property Value Type Description List<string> | Improve this Doc View Source CommentId Declaration [YamlMember(Alias = \"commentId\")] [JsonProperty(\"commentId\")] public string CommentId { get; set; } Property Value Type Description string | Improve this Doc View Source Conceptual Declaration [YamlMember(Alias = \"conceptual\")] [JsonProperty(\"conceptual\")] public string Conceptual { get; set; } Property Value Type Description string | Improve this Doc View Source DerivedClasses Declaration [YamlMember(Alias = \"derivedClasses\")] [MergeOption(MergeOption.Ignore)] [JsonProperty(\"derivedClasses\")] public List<string> DerivedClasses { get; set; } Property Value Type Description List<string> | Improve this Doc View Source Documentation Declaration [YamlMember(Alias = \"documentation\")] [JsonProperty(\"documentation\")] public SourceDetail Documentation { get; set; } Property Value Type Description Microsoft.DocAsCode.DataContracts.Common.SourceDetail | Improve this Doc View Source Examples Declaration [YamlMember(Alias = \"example\")] [JsonProperty(\"example\")] [MergeOption(MergeOption.Replace)] public List<string> Examples { get; set; } Property Value Type Description List<string> | Improve this Doc View Source Exceptions Declaration [YamlMember(Alias = \"exceptions\")] [JsonProperty(\"exceptions\")] public List<ExceptionInfo> Exceptions { get; set; } Property Value Type Description List<ExceptionInfo> | Improve this Doc View Source ExtensionMethods Declaration [YamlMember(Alias = \"extensionMethods\")] [MergeOption(MergeOption.Ignore)] [JsonProperty(\"extensionMethods\")] public List<string> ExtensionMethods { get; set; } Property Value Type Description List<string> | Improve this Doc View Source FullName Declaration [YamlMember(Alias = \"fullName\")] [JsonProperty(\"fullName\")] public string FullName { get; set; } Property Value Type Description string | Improve this Doc View Source FullNameForCSharp Declaration [YamlIgnore] [JsonIgnore] public string FullNameForCSharp { get; set; } Property Value Type Description string | Improve this Doc View Source FullNameForVB Declaration [YamlIgnore] [JsonIgnore] public string FullNameForVB { get; set; } Property Value Type Description string | Improve this Doc View Source FullNames Declaration [ExtensibleMember(\"fullName.\")] [JsonIgnore] public SortedList<string, string> FullNames { get; set; } Property Value Type Description SortedList<string, string> | Improve this Doc View Source Href Declaration [YamlMember(Alias = \"href\")] [JsonProperty(\"href\")] public string Href { get; set; } Property Value Type Description string | Improve this Doc View Source Id Declaration [YamlMember(Alias = \"id\")] [JsonProperty(\"id\")] public string Id { get; set; } Property Value Type Description string | Improve this Doc View Source Implements Declaration [YamlMember(Alias = \"implements\")] [MergeOption(MergeOption.Ignore)] [JsonProperty(\"implements\")] public List<string> Implements { get; set; } Property Value Type Description List<string> | Improve this Doc View Source Inheritance Declaration [YamlMember(Alias = \"inheritance\")] [MergeOption(MergeOption.Ignore)] [JsonProperty(\"inheritance\")] public List<string> Inheritance { get; set; } Property Value Type Description List<string> | Improve this Doc View Source InheritedMembers Declaration [YamlMember(Alias = \"inheritedMembers\")] [MergeOption(MergeOption.Ignore)] [JsonProperty(\"inheritedMembers\")] public List<string> InheritedMembers { get; set; } Property Value Type Description List<string> | Improve this Doc View Source IsExplicitInterfaceImplementation Declaration [YamlMember(Alias = \"isEii\")] [JsonProperty(\"isEii\")] public bool IsExplicitInterfaceImplementation { get; set; } Property Value Type Description bool | Improve this Doc View Source IsExtensionMethod Declaration [YamlMember(Alias = \"isExtensionMethod\")] [JsonProperty(\"isExtensionMethod\")] public bool IsExtensionMethod { get; set; } Property Value Type Description bool | Improve this Doc View Source Metadata Declaration [ExtensibleMember] [JsonIgnore] public Dictionary<string, object> Metadata { get; set; } Property Value Type Description Dictionary<string, object> | Improve this Doc View Source Name Declaration [YamlMember(Alias = \"name\")] [JsonProperty(\"name\")] public string Name { get; set; } Property Value Type Description string | Improve this Doc View Source NameForCSharp Declaration [YamlIgnore] [JsonIgnore] public string NameForCSharp { get; set; } Property Value Type Description string | Improve this Doc View Source NameForVB Declaration [YamlIgnore] [JsonIgnore] public string NameForVB { get; set; } Property Value Type Description string | Improve this Doc View Source Names Declaration [ExtensibleMember(\"name.\")] [JsonIgnore] public SortedList<string, string> Names { get; set; } Property Value Type Description SortedList<string, string> | Improve this Doc View Source NamespaceName Declaration [YamlMember(Alias = \"namespace\")] [JsonProperty(\"namespace\")] public string NamespaceName { get; set; } Property Value Type Description string | Improve this Doc View Source NamesWithType Declaration [ExtensibleMember(\"nameWithType.\")] [JsonIgnore] public SortedList<string, string> NamesWithType { get; set; } Property Value Type Description SortedList<string, string> | Improve this Doc View Source NameWithType Declaration [YamlMember(Alias = \"nameWithType\")] [JsonProperty(\"nameWithType\")] public string NameWithType { get; set; } Property Value Type Description string | Improve this Doc View Source NameWithTypeForCSharp Declaration [YamlIgnore] [JsonIgnore] public string NameWithTypeForCSharp { get; set; } Property Value Type Description string | Improve this Doc View Source NameWithTypeForVB Declaration [YamlIgnore] [JsonIgnore] public string NameWithTypeForVB { get; set; } Property Value Type Description string | Improve this Doc View Source Overload Declaration [YamlMember(Alias = \"overload\")] [JsonProperty(\"overload\")] public string Overload { get; set; } Property Value Type Description string | Improve this Doc View Source Overridden Declaration [YamlMember(Alias = \"overridden\")] [JsonProperty(\"overridden\")] public string Overridden { get; set; } Property Value Type Description string | Improve this Doc View Source Parent Declaration [YamlMember(Alias = \"parent\")] [JsonProperty(\"parent\")] public string Parent { get; set; } Property Value Type Description string | Improve this Doc View Source Platform Declaration [YamlMember(Alias = \"platform\")] [JsonProperty(\"platform\")] [MergeOption(MergeOption.Replace)] public List<string> Platform { get; set; } Property Value Type Description List<string> | Improve this Doc View Source Remarks Declaration [YamlMember(Alias = \"remarks\")] [JsonProperty(\"remarks\")] public string Remarks { get; set; } Property Value Type Description string | Improve this Doc View Source SeeAlsos Declaration [YamlMember(Alias = \"seealso\")] [JsonProperty(\"seealso\")] public List<LinkInfo> SeeAlsos { get; set; } Property Value Type Description List<LinkInfo> | Improve this Doc View Source SeeAlsosUidReference Declaration [JsonIgnore] [YamlIgnore] public List<string> SeeAlsosUidReference { get; } Property Value Type Description List<string> | Improve this Doc View Source Sees Declaration [YamlMember(Alias = \"see\")] [JsonProperty(\"see\")] public List<LinkInfo> Sees { get; set; } Property Value Type Description List<LinkInfo> | Improve this Doc View Source SeesUidReference Declaration [JsonIgnore] [YamlIgnore] public List<string> SeesUidReference { get; } Property Value Type Description List<string> | Improve this Doc View Source Source Declaration [YamlMember(Alias = \"source\")] [JsonProperty(\"source\")] public SourceDetail Source { get; set; } Property Value Type Description Microsoft.DocAsCode.DataContracts.Common.SourceDetail | Improve this Doc View Source Summary Declaration [YamlMember(Alias = \"summary\")] [JsonProperty(\"summary\")] public string Summary { get; set; } Property Value Type Description string | Improve this Doc View Source SupportedLanguages Declaration [YamlMember(Alias = \"langs\")] [JsonProperty(\"langs\")] public string[] SupportedLanguages { get; set; } Property Value Type Description string[] | Improve this Doc View Source Syntax Declaration [YamlMember(Alias = \"syntax\")] [JsonProperty(\"syntax\")] public SyntaxDetailViewModel Syntax { get; set; } Property Value Type Description SyntaxDetailViewModel | Improve this Doc View Source Type Declaration [YamlMember(Alias = \"type\")] [JsonProperty(\"type\")] public MemberType? Type { get; set; } Property Value Type Description MemberType? | Improve this Doc View Source Uid Declaration [YamlMember(Alias = \"uid\")] [JsonProperty(\"uid\")] [MergeOption(MergeOption.MergeKey)] public string Uid { get; set; } Property Value Type Description string Implements Microsoft.DocAsCode.DataContracts.Common.IOverwriteDocumentViewModel"
  },
  "api/Microsoft.DocAsCode.DataContracts.ManagedReference.LinkInfo.html": {
    "href": "api/Microsoft.DocAsCode.DataContracts.ManagedReference.LinkInfo.html",
    "title": "Class LinkInfo | docfx",
    "keywords": "Class LinkInfo Inheritance object LinkInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Microsoft.DocAsCode.DataContracts.ManagedReference Assembly: Microsoft.DocAsCode.Dotnet.dll Syntax [Serializable] public class LinkInfo Properties | Improve this Doc View Source AltText Declaration [YamlMember(Alias = \"altText\")] [JsonProperty(\"altText\")] public string AltText { get; set; } Property Value Type Description string | Improve this Doc View Source CommentId Declaration [YamlMember(Alias = \"commentId\")] [JsonProperty(\"commentId\")] [MergeOption(MergeOption.Ignore)] public string CommentId { get; set; } Property Value Type Description string | Improve this Doc View Source LinkId Declaration [YamlMember(Alias = \"linkId\")] [MergeOption(MergeOption.MergeKey)] [JsonProperty(\"linkId\")] public string LinkId { get; set; } Property Value Type Description string | Improve this Doc View Source LinkType Declaration [YamlMember(Alias = \"linkType\")] [JsonProperty(\"linkType\")] [MergeOption(MergeOption.Ignore)] public LinkType LinkType { get; set; } Property Value Type Description LinkType"
  },
  "api/Microsoft.DocAsCode.DataContracts.ManagedReference.LinkType.html": {
    "href": "api/Microsoft.DocAsCode.DataContracts.ManagedReference.LinkType.html",
    "title": "Enum LinkType | docfx",
    "keywords": "Enum LinkType Namespace: Microsoft.DocAsCode.DataContracts.ManagedReference Assembly: Microsoft.DocAsCode.Dotnet.dll Syntax [Serializable] public enum LinkType Fields Name Description CRef HRef"
  },
  "api/Microsoft.DocAsCode.DataContracts.ManagedReference.MemberType.html": {
    "href": "api/Microsoft.DocAsCode.DataContracts.ManagedReference.MemberType.html",
    "title": "Enum MemberType | docfx",
    "keywords": "Enum MemberType Namespace: Microsoft.DocAsCode.DataContracts.ManagedReference Assembly: Microsoft.DocAsCode.Dotnet.dll Syntax [Serializable] public enum MemberType Fields Name Description Assembly AttachedEvent AttachedProperty Class Constructor Container Default Delegate Enum Event Field Interface Method Namespace Operator Property Struct Toc"
  },
  "api/Microsoft.DocAsCode.DataContracts.ManagedReference.NamedArgumentInfo.html": {
    "href": "api/Microsoft.DocAsCode.DataContracts.ManagedReference.NamedArgumentInfo.html",
    "title": "Class NamedArgumentInfo | docfx",
    "keywords": "Class NamedArgumentInfo Inheritance object NamedArgumentInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Microsoft.DocAsCode.DataContracts.ManagedReference Assembly: Microsoft.DocAsCode.Dotnet.dll Syntax [Serializable] public class NamedArgumentInfo Properties | Improve this Doc View Source Name Declaration [YamlMember(Alias = \"name\")] [JsonProperty(\"name\")] public string Name { get; set; } Property Value Type Description string | Improve this Doc View Source Type Declaration [YamlMember(Alias = \"type\")] [JsonProperty(\"type\")] public string Type { get; set; } Property Value Type Description string | Improve this Doc View Source Value Declaration [YamlMember(Alias = \"value\")] [JsonProperty(\"value\")] public object Value { get; set; } Property Value Type Description object"
  },
  "api/Microsoft.DocAsCode.DataContracts.ManagedReference.PageViewModel.html": {
    "href": "api/Microsoft.DocAsCode.DataContracts.ManagedReference.PageViewModel.html",
    "title": "Class PageViewModel | docfx",
    "keywords": "Class PageViewModel Inheritance object PageViewModel Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Microsoft.DocAsCode.DataContracts.ManagedReference Assembly: Microsoft.DocAsCode.Dotnet.dll Syntax [Serializable] public class PageViewModel Properties | Improve this Doc View Source Items Declaration [YamlMember(Alias = \"items\")] [JsonProperty(\"items\")] public List<ItemViewModel> Items { get; set; } Property Value Type Description List<ItemViewModel> | Improve this Doc View Source Metadata Declaration [ExtensibleMember] [JsonExtensionData] public Dictionary<string, object> Metadata { get; set; } Property Value Type Description Dictionary<string, object> | Improve this Doc View Source References Declaration [YamlMember(Alias = \"references\")] [JsonProperty(\"references\")] public List<ReferenceViewModel> References { get; set; } Property Value Type Description List<ReferenceViewModel> | Improve this Doc View Source ShouldSkipMarkup Declaration [YamlMember(Alias = \"shouldSkipMarkup\")] [JsonProperty(\"shouldSkipMarkup\")] public bool ShouldSkipMarkup { get; set; } Property Value Type Description bool"
  },
  "api/Microsoft.DocAsCode.DataContracts.ManagedReference.SyntaxDetailViewModel.html": {
    "href": "api/Microsoft.DocAsCode.DataContracts.ManagedReference.SyntaxDetailViewModel.html",
    "title": "Class SyntaxDetailViewModel | docfx",
    "keywords": "Class SyntaxDetailViewModel Inheritance object SyntaxDetailViewModel Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Microsoft.DocAsCode.DataContracts.ManagedReference Assembly: Microsoft.DocAsCode.Dotnet.dll Syntax [Serializable] public class SyntaxDetailViewModel Properties | Improve this Doc View Source Content Declaration [YamlMember(Alias = \"content\")] [JsonProperty(\"content\")] public string Content { get; set; } Property Value Type Description string | Improve this Doc View Source ContentForCSharp Declaration [YamlIgnore] [JsonIgnore] public string ContentForCSharp { get; set; } Property Value Type Description string | Improve this Doc View Source ContentForVB Declaration [YamlIgnore] [JsonIgnore] public string ContentForVB { get; set; } Property Value Type Description string | Improve this Doc View Source Contents Declaration [ExtensibleMember(\"content.\")] [JsonIgnore] public SortedList<string, string> Contents { get; set; } Property Value Type Description SortedList<string, string> | Improve this Doc View Source Parameters Declaration [YamlMember(Alias = \"parameters\")] [JsonProperty(\"parameters\")] public List<ApiParameter> Parameters { get; set; } Property Value Type Description List<ApiParameter> | Improve this Doc View Source Return Declaration [YamlMember(Alias = \"return\")] [JsonProperty(\"return\")] public ApiParameter Return { get; set; } Property Value Type Description ApiParameter | Improve this Doc View Source TypeParameters Declaration [YamlMember(Alias = \"typeParameters\")] [JsonProperty(\"typeParameters\")] public List<ApiParameter> TypeParameters { get; set; } Property Value Type Description List<ApiParameter>"
  },
  "api/Microsoft.DocAsCode.DataContracts.ManagedReference.SyntaxLanguage.html": {
    "href": "api/Microsoft.DocAsCode.DataContracts.ManagedReference.SyntaxLanguage.html",
    "title": "Enum SyntaxLanguage | docfx",
    "keywords": "Enum SyntaxLanguage Namespace: Microsoft.DocAsCode.DataContracts.ManagedReference Assembly: Microsoft.DocAsCode.Dotnet.dll Syntax public enum SyntaxLanguage Fields Name Description CSharp Default VB"
  },
  "api/Microsoft.DocAsCode.Docset.html": {
    "href": "api/Microsoft.DocAsCode.Docset.html",
    "title": "Class Docset | docfx",
    "keywords": "Class Docset Provides access to a set of documentations and their associated configs, compilations and models. Inheritance object Docset Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Microsoft.DocAsCode Assembly: Microsoft.DocAsCode.App.dll Syntax public static class Docset Methods | Improve this Doc View Source Build(string, BuildOptions) Builds a docset specified by docfx.json config. Declaration public static Task Build(string configPath, BuildOptions options) Parameters Type Name Description string configPath The path to docfx.json config file. BuildOptions options The build options. Returns Type Description Task A task to await for build completion. | Improve this Doc View Source Build(string) Builds a docset specified by docfx.json config. Declaration public static Task Build(string configPath) Parameters Type Name Description string configPath The path to docfx.json config file. Returns Type Description Task A task to await for build completion."
  },
  "api/Microsoft.DocAsCode.Dotnet.DotnetApiCatalog.html": {
    "href": "api/Microsoft.DocAsCode.Dotnet.DotnetApiCatalog.html",
    "title": "Class DotnetApiCatalog | docfx",
    "keywords": "Class DotnetApiCatalog Provides access to a .NET API definitions and their associated documentation. Inheritance object DotnetApiCatalog Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Microsoft.DocAsCode.Dotnet Assembly: Microsoft.DocAsCode.Dotnet.dll Syntax public static class DotnetApiCatalog Methods | Improve this Doc View Source GenerateManagedReferenceYamlFiles(string, DotnetApiOptions) Generates metadata reference YAML files using docfx.json config. Declaration public static Task GenerateManagedReferenceYamlFiles(string configPath, DotnetApiOptions options) Parameters Type Name Description string configPath The path to docfx.json config file. DotnetApiOptions options Returns Type Description Task A task to await for build completion. | Improve this Doc View Source GenerateManagedReferenceYamlFiles(string) Generates metadata reference YAML files using docfx.json config. Declaration public static Task GenerateManagedReferenceYamlFiles(string configPath) Parameters Type Name Description string configPath The path to docfx.json config file. Returns Type Description Task A task to await for build completion."
  },
  "api/Microsoft.DocAsCode.Dotnet.DotnetApiOptions.html": {
    "href": "api/Microsoft.DocAsCode.Dotnet.DotnetApiOptions.html",
    "title": "Class DotnetApiOptions | docfx",
    "keywords": "Class DotnetApiOptions Provides options to be used with GenerateManagedReferenceYamlFiles(string, DotnetApiOptions). Inheritance object DotnetApiOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: Microsoft.DocAsCode.Dotnet Assembly: Microsoft.DocAsCode.Dotnet.dll Syntax public class DotnetApiOptions Properties | Improve this Doc View Source IncludeApi Customizes the namespaces and types to include in the API catalog. Excluding a parent symbol exclude all child symbols underneath it. Declaration public Func<ISymbol, SymbolIncludeState>? IncludeApi { get; init; } Property Value Type Description Func<ISymbol, SymbolIncludeState> | Improve this Doc View Source IncludeAttribute Customizes the attributes to include in the API catalog. Excluding a parent symbol exclude all child symbols underneath it. Declaration public Func<ISymbol, SymbolIncludeState>? IncludeAttribute { get; init; } Property Value Type Description Func<ISymbol, SymbolIncludeState>"
  },
  "api/Microsoft.DocAsCode.Dotnet.html": {
    "href": "api/Microsoft.DocAsCode.Dotnet.html",
    "title": "Namespace Microsoft.DocAsCode.Dotnet | docfx",
    "keywords": "Namespace Microsoft.DocAsCode.Dotnet Classes DotnetApiCatalog Provides access to a .NET API definitions and their associated documentation. DotnetApiOptions Provides options to be used with GenerateManagedReferenceYamlFiles(string, DotnetApiOptions). Enums SymbolIncludeState Return state of the IncludeApi and IncludeAttribute callbacks."
  },
  "api/Microsoft.DocAsCode.Dotnet.SymbolIncludeState.html": {
    "href": "api/Microsoft.DocAsCode.Dotnet.SymbolIncludeState.html",
    "title": "Enum SymbolIncludeState | docfx",
    "keywords": "Enum SymbolIncludeState Return state of the IncludeApi and IncludeAttribute callbacks. Namespace: Microsoft.DocAsCode.Dotnet Assembly: Microsoft.DocAsCode.Dotnet.dll Syntax public enum SymbolIncludeState Fields Name Description Default Determines whether to include or not using the default configuration. Exclude Ignores default rules and exclude the symbol from the API catalog. Include Ignore default rules and include the symbol in the API catalog."
  },
  "api/Microsoft.DocAsCode.html": {
    "href": "api/Microsoft.DocAsCode.html",
    "title": "Namespace Microsoft.DocAsCode | docfx",
    "keywords": "Namespace Microsoft.DocAsCode Classes BuildOptions Provides options to be used with Build(string, BuildOptions). Docset Provides access to a set of documentations and their associated configs, compilations and models."
  },
  "docs/config.html": {
    "href": "docs/config.html",
    "title": "Config | docfx",
    "keywords": "Config Docfx uses docfx.json as the config file for the site. Most docfx commands operate in a directory containing docfx.json. The build config determines what files are included in the site: { \"build\": { \"content\": [ { \"files\": \"**/*.{md,yml}\", \"exclude\": \"**/include/**\" } ], \"resource\": [ { \"files\": \"**/images/**\" } ] } } The content config defines glob patterns of files that are transformed to HTML by the build process. It is usually the markdown files and auto-generated API YAML files. The resource config defines static resources copied to output as is. URL Management URL is determined by the file path relative to docfx.json. Docfx uses “Ugly URLs”: a file named docs/urls.md is accessible from the docs/urls.html URL. To customize URL pattern for a directory, use the src property to remove the directory name from the URL, and use the dest property to insert an URL prefix: { \"build\": { \"content\": [ { \"files\": \"**/*.{md,yml}\", \"src\": \"articles\", \"dest\": \"docs\" } ] } } In this example, files in the articles directory uses docs as the base URL: The articles/getting-started/installation.md file is accessible by the docs/getting-started/installation.html URL. Metadata Metadata are attributes attached to an file. It helps shape the look and feel of a page and provides extra context to the article. To add metadata to an article, use \"YAML Front Matter\" markdown extension syntax: --- title: a title description: a description --- Some metadata attributes are consistent across a set of content. Use the globalMetadata property in docfx.json to apply the same metadata to all articles: { \"build\": { \"globalMetadata\": { \"_appTitle\": \"My App\" } } } To apply identical metadata values to a folder or a set of content, use the fileMetadata config: { \"build\": { \"fileMetadata\": { \"_appTitle\": { \"articles/dotnet/**/*.md\": \".NET\", \"articles/typescript/**/*.md\": \"TypeScript\" } } } } When the same metadata key is defined in multiple places, YAML Front Matter takes precedence over fileMetadata which in turn takes precedence over globalMetadata. Predefined Metadata Here is a list of predefined metadata recognized by the default docfx site template to customize basic site settings: Name Type Description _appTitle string A string append to every page title. _appName string The name of the site displayed after logo. _appFooter string The footer HTML. _appLogoPath string App logo URL path. _appFaviconPath string Favicon URL path. _enableSearch bool Whether to show the search box. _enableNewTab bool Whether to open external links in a new tab. _disableNavbar bool Whether to show the navigation bar. _disableBreadcrumb bool Whether to show the breadcrumb. _disableToc bool Whether to show the TOC. _disableAffix bool Whether to show the right rail. _noindex bool Whether to include in search results _disableContribution bool Whether to show the \"Improve this Doc\" and _\"View Source\" buttons. _gitContribute object Defines the repo and branch property of git links. _gitUrlPattern string URL pattern of git links. redirect_url string Redirects the current page to the specified redirect URL. URLs can be relative. Tip Docfx produces the right git links for major CI pipelines including GitHub, GitLab, Azure Pipelines, AppVeyor, TeamCity, Jenkins. _gitContribute and _gitUrlPattern are optional on these platforms. Sitemap Docfx produces a sitemap.xml about the pages on your site for search engines like Google to crawl your site more efficiently. The sitemap option in docfx.json controls how sitemaps are generated: { \"build\": { \"sitemap\": { \"baseUrl\": \"https://dotnet.github.iodocfx\", \"priority\": 0.1, \"changefreq\": \"monthly\" } } } Where: baseUrl is the base URL for the website. It should start with http or https and end with a trailing slash. For example, https://dotnet.github.io/docfx/. lastmod is the date of last modification of the page. If not specified, docfx sets the date to the build time. changefreq determines how frequently the page is likely to change. Valid values are always, hourly, daily, weekly, monthly, yearly, never. Default to daily. priority is the priority of this URL relative to other URLs on your site. Valid values range from 0.0 to 1.0. fileOptions is a per file config of the above options. The key is the file glob pattern and value is the sitemap options."
  },
  "docs/dotnet-api-docs.html": {
    "href": "docs/dotnet-api-docs.html",
    "title": ".NET API Docs | docfx",
    "keywords": ".NET API Docs Docfx converts XML documentation comments into rendered HTML documentations. Generate .NET API Docs To add API docs for a .NET project, add a metadata section before the build section in docfx.json config: { \"metadata\": { \"src\": [{ \"files\": [\"**/bin/Release/**.dll\"], \"src\": \"../\" }], \"dest\": \"api\" }, \"build\": { \"content\": [{ \"files\": [ \"api/*.yml\" ] }] } } Docfx generates .NET API docs in 2 stages: The metadata stage uses the metadata config to produce .NET API YAML files at the metadata.dest directory. The build stage transforms the generated .NET API YAML files specified in build.content config into HTML files. These 2 stages can run independently with the docfx metadata command and the docfx build command. The docfx root command runs both metadata and build. Note Glob patterns in docfx currently does not support crawling files outside the directory containing docfx.json. Use the metadata.src property Docfx supports several source formats to generate .NET API docs: Generate from assemblies When the file extension is .dll or .exe, docfx produces API docs by reflecting the assembly and the side-by-side XML documentation file. This approach is build independent and language independent, if you are having trouble with msbuild or using an unsupported project format such as .fsproj, generating docs from assemblies is the recommended approach. Docfx examines the assembly and tries to load the reference assemblies from within the same directory or the global systems assembly directory. In case an reference assembly fails to resolve, use the references property to specify a list of additional reference assembly path: { \"metadata\": { \"src\": [{ \"files\": [\"**/bin/Release/**.dll\"], \"src\": \"../\" }], \"dest\": \"api\", \"references\": [ \"path-to-reference-assembly.dll\" ] }, } Features that needs source code information such as \"Improve this doc\" and \"View source\" is not available using this approach. Generate from projects or solutions When the file extension is .csproj, .vbproj or .sln, docfx uses MSBuildWorkspace to perform a design-time build of the projects before generating API docs. In order to successfully load an MSBuild project, .NET Core SDK must be installed and available globally. The installation must have the necessary workloads and components to support the projects you'll be loading. Run dotnet restore before docfx to ensure that dependencies are available. Running dotnet restore is still needed even if your project does not have NuGet dependencies when Visual Studio is not installed. To troubleshoot MSBuild load problems, run docfx metadata --logLevel verbose to see MSBuild logs. Docfx build the project using Release config by default, additional MSBuild properties can be specified with properties. If your project targets multiple target frameworks, docfx internally builds each target framework of the project. Try specify the TargetFramework MSBuild property to speed up project build: { \"metadata\": { \"src\": [{ \"files\": [\"**/bin/Release/**.dll\"], \"src\": \"../\" }], \"dest\": \"api\", \"properties\": { \"TargetFramework\": \"net6.0\" } }, } Generate from source code When the file extension is .cs or .vb, docfx uses the latest supported .NET Core SDK installed on the machine to build the source code using Microsoft.NET.Sdk. Additional references can be specified in the references config: { \"metadata\": { \"src\": [{ \"files\": [\"**/bin/Release/**.dll\"], \"src\": \"../\" }], \"dest\": \"api\", \"references\": [ \"path-to-reference-assembly.dll\" ] }, } Supported XML Tags Docfx supports Recommended XML tags for C# documentation comments. Warning Docfx parses XML documentation comment as markdown by default, writing XML documentation comments using markdown may cause rendering problems on places that do not support markdown, like in the Visual Studio intellisense window. To disable markdown parsing while processing XML tags, set shouldSkipMarkup to true: { \"metadata\": { \"src\": [{ \"files\": [\"**/bin/Release/**.dll\"], \"src\": \"../\" }], \"dest\": \"api\", \"shouldSkipMarkup\": true } } Filter APIs Docfx shows only the public accessible types and methods callable from another assembly. It also has a set of default filtering rules that excludes common API patterns based on attributes such as [EditorBrowsableAttribute]. To disable the default filtering rules, set the disableDefaultFilter property to true. To show private methods, set the includePrivateMembers config to true. When enabled, internal only langauge keywords such as private or internal starts to appear in the declaration of all APIs, to accurately reflect API accessibility. There are two ways of customizing the API filters: Custom with Code To use a custom filtering with code: Use docfx .NET API generation as a NuGet library: <PackageReference Include=\"Microsoft.DocAsCode.Dotnet\" Version=\"2.62.0\" /> Configure the filter options: var options = new DotnetApiOptions { // Filter based on types IncludeApi = symbol => ... // Filter based on attributes IncludeAttribute = symbol => ... } await DotnetApiCatalog.GenerateManagedReferenceYamlFiles(\"docfx.json\", options); The filter callbacks takes an ISymbol interface and produces an SymbolIncludeState enum to choose between include the API, exclude the API or use the default filtering behavior. The callbacks are raised before applying the default rules but after processing type accessibility rules. Private types and members cannot be marked as include unless includePrivateMembers is true. Hiding the parent symbol also hides all of its child symbols, e.g.: If a namespace is hidden, all child namespaces and types underneath it are hidden. If a class is hidden, all nested types underneath it are hidden. If an interface is hidden, explicit implementations of that interface are also hidden. Custom with Filter Rules To add additional filter rules, add a custom YAML file and set the filter property in docfx.json to point to the custom YAML filter: { \"metadata\": { \"src\": [{ \"files\": [\"**/bin/Release/**.dll\"], \"src\": \"../\" }], \"dest\": \"api\", \"filter\": \"filterConfig.yml\" // <-- Path to custom filter config } } The filter config is a list of rules. A rule can include or exclude a set of APIs based on a pattern. The rules are processed sequentially and would stop when a rule matches. Filter by UID Every item in the generated API docs has a UID (a unique identifier calculated for each API) to filter against using regular expression. This example uses uidRegex to excludes all APIs whose uids start with Microsoft.DevDiv but not Microsoft.DevDiv.SpecialCase. apiRules: - include: uidRegex: ^Microsoft\\.DevDiv\\.SpecialCase - exclude: uidRegex: ^Microsoft\\.DevDiv Filter by Type This example exclude APIs whose uid starts with Microsoft.DevDiv and type is Type: apiRules: - exclude: uidRegex: ^Microsoft\\.DevDiv type: Type Supported value for type are: Namespace Class Struct Enum Interface Delegate Event Field Method Property Type: a Class, Struct, Enum, Interface or Delegate. Member: a Field, Event, Method or Property. API filter are hierarchical, if a namespace is excluded, all types/members defined in the namespace would also be excluded. Similarly, if a type is excluded, all members defined in the type would also be excluded. Filter by Attribute This example excludes all APIs which have AttributeUsageAttribute set to System.AttributeTargets.Class and the Inherited argument set to true: apiRules: - exclude: hasAttribute: uid: System.AttributeUsageAttribute ctorArguments: - System.AttributeTargets.Class ctorNamedArguments: Inherited: \"true\" Where the ctorArguments property specifies a list of match conditions based on constructor parameters and the ctorNamedArguments property specifies match conditions using named constructor arguments."
  },
  "docs/dotnet-yaml-format.html": {
    "href": "docs/dotnet-yaml-format.html",
    "title": ".NET API Docs YAML Format | docfx",
    "keywords": ".NET API Docs YAML Format This document describes the YAML file format to represent .NET API docs. The first line of the YAML file is the magic header ### YamlMime:ManagedReference. 1. Items The following .NET elements are defined as items in metadata: Namespaces Types, including class, struct, interface, enum, delegate Type members, including field, property, method, event Other elements such as parameters and generic parameters are not standalone items, they're part of other items. 2. Identifiers 2.1 Unique Identifiers For any item in .NET languages, its UID is defined by concatenating its parent's UID and its own ID with a dot. The ID for each kind of item is defined in following sections. The basic principle here is to make ID format close to source code and easy for human reading. UID is similar to the document comment id, which is started with type prefix, for example, T:, or M:, but UID do not. There MUST NOT be any whitespace between method name, parentheses, parameters, and commas. 2.2 Spec Identifiers Spec identifier is another form of UID. It can spec a generic type with type arguments (for example, for parameters, return types or inheritances) and these UIDs are unique in one yaml file. It is a simple modified Unique Identifiers, when it contains generic type arguments, it will use {Name} instead `N. For type parameter, it will be {Name}. And it also supports array and pointer. Example 2.2 Spec Identifier C#: namespace Foo { public class Bar { public unsafe List<String> FooBar<TArg>(int[] arg1, byte* arg2, TArg arg3, List<TArg[]> arg4) { return null; } } } YAML: references: - uid: System.Collections.Generic.List{System.String} - uid: System.Int32[] - uid: System.Byte* - uid: {TArg} - uid: System.Collections.Generic.List{{TArg}[]} 3. Namespaces For all namespaces, they are flat, e.i. namespaces do not have the parent namespace. So for any namespace, ID is always same with its UID. Example 3 Namespace C#: namespace System.IO { } YAML: uid: System.IO id: System.IO name: System.IO fullName: System.IO The children of namespace are all the visible types in the namespace. 4. Types Types include classes, structs, interfaces, enums, and delegates. They have following properties: summary, remarks, syntax, namespace, assemblies, inheritance. The parents of types are namespaces. The children of types are members. ID ID for a type is also its name. Example 4 Type C#: namespace System { public class String {} public struct Boolean {} public interface IComparable {} public enum ConsoleColor {} public delegate void Action(); } YAML: - uid: System.String id: String name.csharp: String fullName.csharp: System.String - uid: System.Boolean id: Boolean name.csharp: Boolean fullName.csharp: System.String - uid: System.IComparable id: IComparable name.csharp: IComparable fullName.csharp: System.IComparable - uid: System.ConsoleColor id: ConsoleColor name.csharp: ConsoleColor fullName.csharp: System.ConsoleColor - uid: System.Action id: Action name.csharp: Action fullName.csharp: System.Action 4.1 ID for Nested Types For nested types, ID is defined by concatenating the ID of all its containing types and the ID of itself, separated by a dot. The parent type of a nested type is its containing namespace, rather than its containing type. Example 4.1 Nested type C#: namespace System { public class Environment { public enum SpecialFolder {} } } YAML: uid: System.Environment.SpecialFolder id: Environment.SpecialFolder name.csharp: Environment.SpecialFolder fullName.csharp: System.Environment.SpecialFolder 4.2 Inheritance Only class contains inheritance, and the inheritance is a list of spec id. Example 4.2 Inheritance C#: namespace System.Collections.Generic { public class KeyedByTypeCollection<TItem> : KeyedCollection<Type, TItem> { } } YAML: uid : System.Collections.Generic.KeyedByTypeCollection`1 inheritance: - System.Collections.ObjectModel.KeyedCollection{System.Type,{TItem}} - System.Collections.ObjectModel.Collection{{TItem}} - System.Object 4.3 Syntax The syntax part for type contains declaration, and descriptions of type parameters for different languages. For delegates, it also contains descriptions of parameters and a return type. 5. Members Members include fields, properties, methods, and events. They have the following properties: summary, remarks, exceptions, and syntax. The parents of members are types. Members never have children, and all parameter types or return types are spec id. 5.1 Constructors The ID of a constructor is defined by #ctor, followed by the list of the UIDs of its parameter types: When a constructor does not have parameter, its ID MUST NOT end with parentheses. The syntax part for constructors contains a special language declaration, and descriptions of parameters. Example 5.1 Constructor C#: namespace System { public sealed class String { public String(); public String(char[] chars); } } YAML: - uid: System.String.#ctor id: #ctor name.csharp: String() fullName.csharp: System.String.String() - uid: System.String.#ctor(System.Char[]) id: #ctor(System.Char[]) name.csharp: String(Char[]) fullName.csharp: System.String.String(System.Char[]) 5.2 Methods The ID of a method is defined by its name, followed by the list of the UIDs of its parameter types: method_name(param1,param2,...) When a method does not have parameter, its ID MUST end with parentheses. The syntax part for method contains a special language declaration, and descriptions of type parameters for generic method, descriptions of parameters and return type. Example 5.2 Method C#: namespace System { public sealed class String { public String ToString(); public String ToString(IFormatProvider provider); } } YAML: - uid: System.String.ToString id: ToString name.csharp: ToString() fullName.csharp: System.String.ToString() - uid: System.String.ToString(System.IFormatProvider) id: ToString(System.IFormatProvider) name.csharp: ToString(IFormatProvider) fullName.csharp: System.String.ToString(System.IFormatProvider) 5.2.1 Explicit Interface Implementation The ID of an explicit interface implementation (EII) member MUST be prefixed by the UID of the interface it implements and replace . to #. Example 2.6 Explicit interface implementation (EII) C#: namespace System { using System.Collections; public sealed class String : IEnumerable { IEnumerator IEnumerable.GetEnumerator(); } } YAML: - uid: \"System.String.System#Collections#IEnumerable#GetEnumerator\" id: \"System#Collections#IEnumerable#GetEnumerator\" name.csharp: IEnumerable.GetEnumerator() fullName.csharp: System.String.System.Collections.IEnumerable.GetEnumerator() 5.4 Operator Overloads The IDs of operator overloads are same with the metadata name (for example, op_Equality). The names of operator overloads are similar to MSDN, just remove op_ from the metadata name of the method. For instance, the name of the equals (==) operator is Equality. Type conversion operator can be considered a special operator whose name is the UID of the target type, with one parameter of the source type. For example, an operator that converts from string to int should be Explicit(System.String to System.Int32). The syntax part for methods contains a special language declaration, descriptions of parameters and return type. Example 5.4 Operator overload namespace System { public struct Decimal { public static implicit operator Decimal(Char value); } public sealed class String { public static bool operator ==(String a, String b); } } YAML: - uid: System.Decimal.op_Implicit(System.Char)~System.Decimal id: op_Implicit(System.Char)~System.Decimal name.csharp: Implicit(Char to Decimal) fullName.csharp: System.Decimal.Implicit(System.Char to System.Decimal) - uid: System.String.op_Equality(System.String,System.String) id: op_Equality(System.String,System.String) name.csharp: Equality(String,String) fullName.csharp: System.String.Equality(System.String,System.String) Please check overloadable operators for all overloadable operators. 5.5 Field, Property or Event The ID of field, property or event is its name. The syntax part for field contains a special language declaration and descriptions of field type. For property, it contains a special language declaration, descriptions of parameters, and return type. For event, it contains a special language declaration and descriptions of event handler type. Example 5.5 Field, Property and Event C#: namespace System { public sealed class String { public static readonly String Empty; public int Length { get; } } public static class Console { public static event ConsoleCancelEventHandler CancelKeyPress; } } YAML: - uid: System.String.Empty id: Empty name.csharp: Empty fullName.csharp: System.String.Empty - uid: System.String.Length id: Length name.csharp: Length fullName.csharp: System.String.Length - uid: System.Console.CancelKeyPress id: CancelKeyPress name.csharp: CancelKeyPress fullName.csharp: System.Console.CancelKeyPress 5.6 Indexer Indexer operator's name is metadata name, by default, it is Item, with brackets and parameters. Example 5.6 Indexer namespace System.Collections { public interface IList { object this[int index] { get; set; } } } YAML: - uid: \"System.Collections.IList.Item[System.Int32]\" id: \"Item[System.Int32]\" name.csharp: Item[Int32] fullName.csharp: System.Collections.IList.Item[System.Int32] 6. Generics The ID of a generic type is its name with followed by `n, n and the count of generic type count, which is the same as the rule for document comment ID. For example, Dictionary`2. The ID of a generic method uses postfix ``n, n is the count of in method parameters, for example, System.Tuple.Create``1(``0). Example 2.7 Generic namespace System { public static class Tuple { public static Tuple<T1> Create<T1>(T1 item1); public static Tuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2); } } YAML: - uid: System.Tuple.Create``1(``0) id: Create``1(``0) name.csharp: Create<T1>(T1) fullName.csharp: System.Tuple.Create<T1>(T1) - uid: System.Tuple.Create``2(``0,``1) id: Create``2(``0,``1) name.csharp: Create<T1,T2>(T1,T2) fullName.csharp: System.Tuple.Create<T1,T2>(T1,T2) 7. Reference The reference contains the following members: name, fullName, summary, isExternal, href, and more. The UID in reference can be a Spec Id, then it contains one more member: spec. The spec in reference is very like a list of lightweight references, it describes how to compose the generic type in some special language. Example 7 spec for references YAML: references: - uid: System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{System.Int32}} name.csharp: Dictionary<String, List<Int32>> fullName.csharp: System.Collections.Generic.Dictionary<System.String, System.Collections.Generic.List<System.Int32>> spec.csharp: - uid: System.Collections.Generic.Dictionary`2 name: Dictionary fullName: System.Collections.Generic.Dictionary isExternal: true - name: < fullName: < - uid: System.String name: String fullName: System.String isExternal: true - name: ', ' fullName: ', ' - uid: System.Collections.Generic.List`1 name: List fullName: System.Collections.Generic.List isExternal: true - name: < fullName: < - uid: System.Int32 name: Int32 fullName: System.Int32 isExternal: true - name: '>' fullName: '>' - name: '>' fullName: '>'"
  },
  "docs/markdown.html": {
    "href": "docs/markdown.html",
    "title": "Markdown | docfx",
    "keywords": "Markdown Markdown is a lightweight markup language with plain text formatting syntax. Docfx supports CommonMark compliant Markdown parsed through the Markdig parsing engine. Markdown Extensions Docfx supports additional markdown syntax that provide richer content. These syntax are specific to docfx and won't be rendered elsewhere like GitHub. To use a custom markdown extension: Use docfx as a NuGet library: <PackageReference Include=\"Microsoft.DocAsCode.App\" Version=\"2.61.0\" /> Configure the markdig markdown pipeline: var options = new BuildOptions { // Enable custom markdown extensions here ConfigureMarkdig = pipeline => pipeline.UseCitations(), } await Docset.Build(\"docfx.json\", options); Here is a list of markdown extensions provided by docfx by default. Alerts Alerts are block quotes that render with colors and icons that indicate the significance of the content. The following alert types are supported: > [!NOTE] > Information the user should notice even if skimming. > [!TIP] > Optional information to help a user be more successful. > [!IMPORTANT] > Essential information required for user success. > [!CAUTION] > Negative potential consequences of an action. > [!WARNING] > Dangerous certain consequences of an action. They look like this in rendered page: Note Information the user should notice even if skimming. Tip Optional information to help a user be more successful. Important Essential information required for user success. Caution Negative potential consequences of an action. Warning Dangerous certain consequences of an action. Video You can embed a video in your page by using the following Markdown syntax: > [!Video embed_link] Example: > [!Video https://www.youtube.com/embed/Sz1lCeedcPI] This will be rendered as: Image You can embed a image in your page by using the following Markdown syntax: ![ <alt-text> ]( <image-link> ) Example: ![alt-text](https://learn.microsoft.com/en-us/media/learn/not-found/learn-not-found-light-mode.png?branch=main) This will be rendered as: Include Markdown Files Where markdown files need to be repeated in multiple articles, you can use an include file. The includes feature replace the reference with the contents of the included file at build time. You can reuse a common text snippet within a sentence using inline include: Text before [!INCLUDE [<title>](<filepath>)] and after. Or reuse an entire Markdown file as a block, nested within a section of an article. Block include is on its own line: [!INCLUDE [<title>](<filepath>)] Where <title> is the name of the file and <filepath> is the relative path to the file. Included markdown files needs to be excluded from build, they are usually placed in the /includes folder. Code Snippet There are several ways to include code in an article. The code snippet syntax replaces code from another file: [!code-csharp[](Program.cs)] You can include selected lines from the code snippet using region or line range syntax: [!code-csharp[](Program.cs#region)] [!code-csharp[](Program.cs#L12-L16)] Code snippets are indicated by using a specific link syntax described as follows: [!code-<language>[](<filepath><query-options>)] Where <language> is the syntax highlighting language of the code and <filepath> is the relative path to the markdown file. Highlight Selected Lines Code Snippets typically include more code than necessary in order to provide context. It helps readability when you highlight the key lines that you're focusing on. To highlight key lines, use the highlight query options: [!code-csharp[](Program.cs?highlight=2,5-7,9-)] The example highlights lines 2, line 5 to 7 and lines 9 to the end of the file. using System; using Azure; using Azure.Storage; using Azure.Storage.Blobs; class Program { static void Main(string[] args) { // Define the connection string for the storage account string connectionString = \"DefaultEndpointsProtocol=https;AccountName=<your-account-name>;AccountKey=<your-account-key>;EndpointSuffix=core.windows.net\"; // Create a new BlobServiceClient using the connection string var blobServiceClient = new BlobServiceClient(connectionString); // Create a new container var container = blobServiceClient.CreateBlobContainer(\"mycontainer\"); // Upload a file to the container using (var fileStream = File.OpenRead(\"path/to/file.txt\")) { container.UploadBlob(\"file.txt\", fileStream); } // Download the file from the container var downloadedBlob = container.GetBlobClient(\"file.txt\").Download(); using (var fileStream = File.OpenWrite(\"path/to/downloaded-file.txt\")) { downloadedBlob.Value.Content.CopyTo(fileStream); } } } Tabs Tabs enable content that is multi-faceted. They allow sections of a document to contain variant content renderings and eliminates duplicate content. Here's an example of the tab experience: Linux Windows Content for Linux... Content for Windows... The above tab group was created with the following syntax: # [Linux](#tab/linux) Content for Linux... # [Windows](#tab/windows) Content for Windows... --- Tabs are indicated by using a specific link syntax within a Markdown header. The syntax can be described as follows: # [Tab Display Name](#tab/tab-id) A tab starts with a Markdown header, #, and is followed by a Markdown link [](). The text of the link will become the text of the tab header, displayed to the customer. In order for the header to be recognized as a tab, the link itself must start with #tab/ and be followed by an ID representing the content of the tab. The ID is used to sync all same-ID tabs across the page. Using the above example, when a user selects a tab with the link #tab/windows, all tabs with the link #tab/windows on the page will be selected. Dependent tabs It's possible to make the selection in one set of tabs dependent on the selection in another set of tabs. Here's an example of that in action: .NET .NET TypeScript TypeScript REST API .NET content for Linux... .NET content for Windows... TypeScript content for Linux... TypeScript content for Windows... REST API content, independent of platform... Notice how changing the Linux/Windows selection above changes the content in the .NET and TypeScript tabs. This is because the tab group defines two versions for each .NET and TypeScript, where the Windows/Linux selection above determines which version is shown for .NET/TypeScript. Here's the markup that shows how this is done: # [.NET](#tab/dotnet/linux) .NET content for Linux... # [.NET](#tab/dotnet/windows) .NET content for Windows... # [TypeScript](#tab/typescript/linux) TypeScript content for Linux... # [TypeScript](#tab/typescript/windows) TypeScript content for Windows... # [REST API](#tab/rest) REST API content, independent of platform... ---"
  },
  "docs/pdf.html": {
    "href": "docs/pdf.html",
    "title": "Create PDF Files | docfx",
    "keywords": "Create PDF Files Docfx produces PDF files based on the TOC structure. Install wkhtmltopdf To build PDF files, first install wkhtmltopdf by downloading the latest binary from the official site or install using chocolatey: choco install wkhtmltopdf. Make sure the wkhtmltopdf command is added to PATH environment variable and is available in the terminal. PDF Config Add a pdf section in docfx.json: { \"pdf\": { \"content\": [{ \"files\": [ \"**/*.{md,yml}\" ] }], \"wkhtmltopdf\": { \"additionalArguments\": \"--enable-local-file-access\" }, } } Most of the config options are the same as build config. The wkhtmltopdf config contains additional details to control wkhtmltopdf behavior: filePath: Path to wkhtmltopdf.exe. additionalArguments: Additional command line arguments passed to wkhtmltopdf. Usually needs --enable-local-file-access to allow access to local files. Running docfx command againt the above configuration produces a PDF file for every TOC included in the content property. The PDF files are placed under the _site_pdf folder based on the TOC name. See this sample on an example PDF config. Add Cover Page A cover page is the first PDF page before the TOC page. To add a cover page, add a cover.md file alongside toc.yml. The content of cover.md will be rendered as the PDF cover page."
  },
  "docs/rest-api-docs.html": {
    "href": "docs/rest-api-docs.html",
    "title": "Add REST API docs | docfx",
    "keywords": "Add REST API docs Docfx generates REST API documentation from Swagger 2.0 files. To add REST API docs, include the swagger JSON file to the build config in docfx.json: { \"metadata\": { \"src\": [ \"../src/**/bin/Release/**.dll\" ], \"dest\": \"api\" }, \"build\": { \"content\": [{ \"files\": [ \"**/*.swagger.json\" ] // <-- Include swagger JSON files }] } } Each swagger file produces one output HTML file. Organize REST APIs using Tags APIs can be organized using the Tag Object. An API can be associated with one or more tags. Untagged APIs are put in the Other apis section. This example defines the Basic and Advanced tags and organize APIs using the two tags. The x-bookmark-id property specifies the URL fragment for the tag. { \"swagger\": \"2.0\", \"info\": { \"title\": \"Contacts\", \"version\": \"1.6\" }, \"host\": \"microsoft.com\", \"basePath\": \"/docfx\", \"schemes\": [ \"https\" ], \"tags\": [ { \"name\": \"Basic\", \"x-bookmark-id\": \"BasicBookmark\", \"description\": \"Basic description\" }, { \"name\": \"Advanced\", \"description\": \"Advanced description\" } ], \"paths\": { \"/contacts\": { \"get\": { \"operationId\": \"get_contacts\", \"tags\": [ \"Basic\", \"Advanced\" ] }, \"set\": { \"operationId\": \"set_contacts\", \"tags\": [ \"Advanced\" ] }, \"delete\": { \"operationId\": \"delete_contacts\" } } } } The above example produces the following layout: Basic ├─ get_contacts Advanced ├─ get_contacts ├─ set_contacts Other APIs ├─ delete_contacts"
  },
  "docs/table-of-contents.html": {
    "href": "docs/table-of-contents.html",
    "title": "Table of Contents | docfx",
    "keywords": "Table of Contents A table of contents (TOC) defines the structure of a set of documents. YAML TOC To add a TOC, create a file named toc.yml. Here's the structure for a simple YAML TOC: items: - name: Tutorial items: - name: Introduction href: tutorial.md - name: Step 1 href: step-1.md - name: Step 2 href: step-2.md - name: Step 3 href: step-3.md The YAML document is a tree of TOC nodes, each of which has these properties: name: The display name for the TOC node. href: The path the TOC node leads to. Optional because a node can exist just to parent other nodes. items: If a node has children, they're listed in the items array. Navigation Bar The toc.yml file in the docfx.json folder will be used to fill the content of the navigation bar at the top of the page. Nested TOCs To nest a TOC within another TOC, set the href property to point to the toc.yml file that you want to nest. You can also use this structure as a way to reuse a TOC structure in one or more TOC files. Consider the following two toc.yml files: toc.yml: items: - name: Overview href: overview.md - name: Reference href: api/toc.yml api/toc.yml: items: - name: System.String href: system.string.yml - name: System.Float href: system.float.yml This structure renders as follows: Overview Reference ├─ System.String ├─ System.Float"
  },
  "docs/template.html": {
    "href": "docs/template.html",
    "title": "Template | docfx",
    "keywords": "Template Template defines the appearance of the website. Docfx ships a default website template with the same look and feel as this site. Additional templates are available at the Template Gallery. Create a Custom Template To build your own template, create a new folder and add it to templates config in docfx.json: { \"build\": { \"templates\": [ \"default\", \"my-template\" // <-- Path to custom template ] } } Add your custom CSS file to styles/main.css and JavaScript file to styles/main.js. Docfx loads these 2 files and use them to style the website. This is an example stylesheet that adjust the font size of article headers: /* file: styles/main.css */ article h1 { font-size: 40px; } Custom HTML Templates In addition to CSS and JavaScript, you can customize how docfx generates HTML using Mustache Templates. Create a partials/footer.tmpl.partial file to replace the footer. This example update the footer to show a GitHub Follow button. <footer> <a class=\"github-button\" href=\"{{source.remote.repo}}\" data-size=\"large\" aria-label=\"Follow\">Follow</a> <script async defer src=\"https://buttons.github.io/buttons.js\"></script> </footer> The list of customizable HTML components are: partials/logo.tmpl.partial: The logo in the header. partials/footer.tmpl.partial: The footer at the bottom of the page. partials/affix.tmpl.partial: The right rail. partials/breadcrumb.tmpl.partial: The breadcrumb bar. Template Variables Metadata and other properties are available to the template engine. To see the template JSON input model, build with --exportRawModel command line option. Here are some predefined variables available to the template: Name Description _rel The relative path of the root output folder from current output file. For example, if the output file is a/b/c.html from root output folder, then the value is ../../. _path The path of current output file starting from root output folder. _navPath The relative path of the root TOC file from root output folder, if exists. The root TOC file stands for the TOC file in root output folder. For example, if the output file is html file, the value is toc.html. _navRel The relative path from current output file to the root TOC file, if exists. For example, if the root TOC file is toc.html from root output folder, the value is empty. _navKey The original file path of the root TOC file starting with ~/. ~/ stands for the folder where docfx.json is in, for example, ~/toc.md. _tocPath The relative path of the TOC file that current output file belongs to from root output folder, if current output file is in that TOC file. If current output file is not defined in any TOC file, the nearest TOC file is picked. _tocRel The relative path from current output file to its TOC file. For example, if the TOC file is a/toc.html from root output folder, the value is ../. _tocKey The original file path of the TOC file starting with ~/. ~/ stands for the folder where docfx.json is in, for example, ~/a/toc.yml."
  },
  "extensions/packages.html": {
    "href": "extensions/packages.html",
    "title": "Packages | docfx",
    "keywords": ""
  },
  "extensions/templates.html": {
    "href": "extensions/templates.html",
    "title": "Templates | docfx",
    "keywords": ""
  },
  "extensions/tools.html": {
    "href": "extensions/tools.html",
    "title": "Tools | docfx",
    "keywords": ""
  },
  "index.html": {
    "href": "index.html",
    "title": "Quick Start | docfx",
    "keywords": "Quick Start Build your technical documentation site with docfx. Converts .NET assembly, XML code comment, REST API Swagger files and markdown into rendered HTML pages, JSON model or PDF files. Create a New Website In this section we will build a simple documentation site on your local machine. Prerequisites Familiarity with the command line Install .NET SDK 6.0 or higher Make sure you have .NET SDK installed, then open a terminal and enter the following command to install the latest docfx: dotnet tool update -g docfx To create a new docset, run: docfx init --quiet This command creates a new docset under the docfx_project directory. To build the docset, run: docfx docfx_project/docfx.json --serve Now you can preview the website on http://localhost:8080. To preview your local changes, save changes then run this command in a new terminal to rebuild the website: docfx docfx_project/docfx.json Publish to GitHub Pages Docfx produces static HTML files under the _site folder ready for publishing to any static site hosting servers. To publish to GitHub Pages: Enable GitHub Pages. Upload _site folder to GitHub Pages using GitHub actions. This example uses peaceiris/actions-gh-pages to publish to the gh-pages branch: # Your GitHub workflow file under .github/workflows/ jobs: publish-docs: runs-on: ubuntu-latest steps: - name: Chekout uses: actions/checkout@v3 - name: Dotnet Setup uses: actions/setup-dotnet@v3 with: dotnet-version: 7.x - run: dotnet tool update -g docfx - run: docfx docfx_project/docfx.json - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: docs/_site Use the NuGet Library You can also use docfx as a NuGet library: <PackageReference Include=\"Microsoft.DocAsCode.App\" Version=\"2.60.0\" /> Then build a docset using: await Microsoft.DocAsCode.Docset.Build(\"docfx.json\"); See API References for additional APIs. Next Steps Write Articles Organize Contents Configure Website Add .NET API Docs"
  },
  "README.html": {
    "href": "README.html",
    "title": "| docfx",
    "keywords": "Documentation project uses docfx.console nuget package to generate documentation for docfx project, along with conceputal files, with docfx.json to provide configuration for docfx."
  },
  "spec/docfx_document_schema.html": {
    "href": "spec/docfx_document_schema.html",
    "title": "DocFX Document Schema v1.0 Specification | docfx",
    "keywords": "DocFX Document Schema v1.0 Specification 1. Introduction DocFX supports different document processors to handle different kinds of input. For now, if the data model changes a bit, a new document processor is needed, even most of the work in processors are the same. DocFX Document Schema (abbreviated to THIS schema below) is introduced to address this problem. This schema is a JSON media type for defining the structure of a DocFX document. This schema is intended to annotate, validate and interpret the document data. 2. Conventions and Terminology The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119. 3. Overview DocFX Document Schema is in JSON format. It borrows most syntax from JSON Schema, while it also introduces some other syntax to manipulate the data. 3.1 Annotation THIS schema is a JSON based format for the structure of a DocFX document. 3.2 Validation JSON schema validation already defines many keywords. This schema starts from supporting limited keyword like type, properties. 3.3 Interpretation Besides annotate and validate the input document model, THIS schema also defines multiple interpretations for each property of the document model. For example, a property named summary contains value in Markdown format, THIS schema can define a markup interpretation for the summary property, so that the property can be marked using DFM syntax. 4. General Considerations THIS schema leverages JSON schema definition, that is to say, keywords defined in JSON schema keeps its meaning in THIS schema when it is supported by THIS schema. 5. Detailed Specification Format The files describing DocFX document model in accordance with the DocFX document schema specification are represented as JSON objects and conform to the JSON standards. YAML, being a superset of JSON, can be used as well to represent a DocFX document schema specification file. All field names in the specification are case sensitive. This schema exposes two types of fields. Fixed fields, which have a declared name, and Patterned fields, which declare a regex pattern for the field name. Patterned fields can have multiple occurrences as long as each has a unique name. By convention, the schema file is suffixed with .schema.json. Data Types Primitive data types in THIS schema are based on JSON schema Draft 6 4.2 Instance Schema For a given field, * as the starting character in Description cell stands for required. Schema Object This is the root document object for THIS schema. Fixed Field Field Name Type Description $schema string *The version of the schema specification, for example, https://dotnet.github.io/docfx/schemas/v1.0/schema.json#. version string *The version of current schema object. id string It is best practice to include an id property as an unique identifier for each schema. title string The title of current schema, LandingPage, for example. In DocFX, this value can be used to determine what kind of documents apply to this schema, If not specified, file name before schema.json of this schema is used. Note that . is not allowed. description string A short description of current schema. type string *The type of the root document model MUST be object. properties Property Definitions Object An object to hold the schema of all the properties. metadata string In json-pointer format as defined in http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.3.9. The format for JSON pointer is defined by https://tools.ietf.org/html/rfc6901, referencing to the metadata object. Metadata object is the object to define the metadata for current document, and can be also set through globalMetadata or fileMetadata in DocFX. The default value for metadata is empty which stands for the root object. Patterned Field Field Name Type Description ^x- Any Allows extensions to THIS schema. The field name MUST begin with x-, for example, x-internal-id. The value can be null, a primitive, an array or an object. Property Definitions Object It is an object where each key is the name of a property and each value is a schema to describe that property. Patterned Field Field Name Type Description {name} Property Object The schema object for the {name} property Property Object An object to describe the schema of the value of the property. Fixed Field Field Name Type Description title string The title of the property. description string A lengthy explanation about the purpose of the data described by the schema. default what type defined The default value for current field. type string The type of the root document model. Refer to type keyword for detailed description. properties Property Definitions Object An object to hold the schema of all the properties if type for the model is object. Omitting this keyword has the same behavior as an empty object. items Property Object An object to hold the schema of the items if type for the model is array. Omitting this keyword has the same behavior as an empty schema. reference string Defines whether current property is a reference to the actual value of the property. Refer to reference for detailed explanation. contentType string Defines the content type of the property. Refer to contentType for detailed explanation. tags array Defines the tags of the property. Refer to tags for detailed explanation. mergeType string Defines how to merge the property. Omitting this keyword has the same behavior as merge. Refer to mergeType for detailed explanation. xrefProperties array Defines the properties of current object when it is cross referenced by others. Each item is the name of the property in the instance. Refer to xrefProperties for detailed description of how to leverage this property. Patterned Field Field Name Type Description ^x- Any Allows extensions to THIS schema. The field name MUST begin with x-, for example, x-internal-id. The value can be null, a primitive, an array or an object. 6. Keywords in detail 6.1 type Same as in JSON schema: http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.25 The value of this keyword MUST be either a string or an array. If it is an array, elements of the array MUST be strings and MUST be unique. String values MUST be one of the six primitive types (\"null\", \"boolean\", \"object\", \"array\", \"number\", or \"string\"), or \"integer\" which matches any number with a zero fractional part. An instance validates if and only if the instance is in any of the sets listed for this keyword. 6.2 reference It defines whether current property is a reference to the actual value of the property. The values MUST be one of the following: Value Description none It means the property is not a reference. file It means current property stands for a file path that contains content to be included. 6.3 contentType It defines how applications interpret the property. If not defined, the behavior is similar to default value. The values MUST be one of the following: Value Description default It means that no interpretion will be done to the property. uid type MUST be string. With this value, the property name MUST be uid. It means the property defines a unique identifier inside current document model. href type MUST be string. It means the property defines a file link inside current document model. Application CAN help to validate if the linked file exists, and update the file link if the linked file changes its output path. xref type MUST be string. It means the property defines a UID link inside current document model. Application CAN help to validate if the linked UID exists, and resolve the UID link to the corresponding file output link. file type MUST be string. It means the property defines a file path inside current document model. Application CAN help to validate if the linked file exists, and resolve the path to the corresponding file output path. The difference between file and href is that href is always URL encoded while file is not. markdown type MUST be string. It means the property is in DocFX flavored Markdown syntax. Application CAN help to transform it into HTML format. 6.4 tags The value of this keyword MUST be an array, elements of the array MUST be strings and MUST be unique. It provides hints for applications to decide how to interpret the property, for example, localizable tag can help Localization team to interpret the property as localizable. 6.5 mergeType The value of this keyword MUST be a string. It specifies how to merge two values of the given property. One use scenario is how DocFX uses the overwrite files to overwrite the existing values. In the below table, we use source and target to stands for the two values for merging. The value MUST be one of the following: Value Description key If key for source equals to the one for target, these two values are ready to merge. merge The default behavior. For array, items in the list are merged by key for the item. For string or any value type, target replaces source. For object, merge each property along with its own merge value. replace target replaces source. ignore source is not allowed to be merged. 6.6 xrefProperties The value of this keyword MUST be an array of string. Each string value is the property name of current object that will be exported to be Cross Referenced by others. To leverage this feature, a new xref syntax with template attribute is support: <xref uid=\"{uid}\" template=\"{path_of_partial_template}\" /> For the parital template, the input model is the object containing properties xrefProperties defines. For example, in the sample schema defined by 7. Samples, \"xrefProperties\": [ \"title\", \"description\" ],, title and description are xrefProperties for uid webapp. A partial template to render this xref, for example, named partials/overview.tmpl, looks like: {{title}}: {{{description}}} When someone references this uid using <xref uid=\"webapp\" template=\"partials/overview.tmpl\", docfx expand this xref into the following html: Web Apps Documentation: <p>This is description</p> In this way, users can not only cross reference others to get the target url, but also cross reference other properties as they like. A common usage of this is the Namespace page in ManagedReference. The Namespace page shows a table of its Classes with the summary of the Class, with the help of xrefProperties, the source of truth summary is always from Class. For the Namespace page, it can, for example: Define a class.tr.tmpl template: <tr><td>{{name}}</td><td>{{{summary}}}</td></tr> The namespace namespace.tmpl template, use xref to render its children classes: {{#children}} <xref uid=\"{{uid}}\" template=\"class.tr.tmpl\" /> {{/children}} 7. Samples Here's an sample of the schema. Assume we have the following YAML file: ### YamlMime:LandingPage title: Web Apps Documentation description: This is description uid: webapp metadata: title: Azure Web Apps Documentation - Tutorials, API Reference meta.description: Learn how to use App Service Web Apps to build and host websites and web applications. services: app-service author: apexprodleads manager: carolz ms.service: app-service ms.tgt_pltfrm: na ms.devlang: na ms.topic: landing-page ms.date: 01/23/2017 ms.author: carolz sections: - title: 5-Minute Quickstarts children: - text: .NET href: app-service-web-get-started-dotnet.md - text: Node.js href: app-service-web-get-started-nodejs.md - text: PHP href: app-service-web-get-started-php.md - text: Java href: app-service-web-get-started-java.md - text: Python href: app-service-web-get-started-python.md - text: HTML href: app-service-web-get-started-html.md - title: Step-by-Step Tutorials children: - content: \"Create an application using [.NET with Azure SQL DB](app-service-web-tutorial-dotnet-sqldatabase.md) or [Node.js with MongoDB](app-service-web-tutorial-nodejs-mongodb-app.md)\" - content: \"[Map an existing custom domain to your application](app-service-web-tutorial-custom-domain.md)\" - content: \"[Bind an existing SSL certificate to your application](app-service-web-tutorial-custom-SSL.md)\" In this sample, we want to use the JSON schema to describe the overall model structure. Further more, the href is a file link. It need to be resolved from the relative path to the final href. The content property need to be marked up as a Markdown string. The metadata need to be tagged for further custom operations. We want to use section's title as the key for overwrite section array. Here's the schema to describe these operations: { \"$schema\": \"https://dotnet.github.io/docfx/schemas/v1.0/schema.json#\", \"version\": \"1.0.0\", \"id\": \"https://github.com/dotnet/docfx/schemas/landingpage.schema.json\", \"title\": \"LandingPage\", \"description\": \"The schema for landing page\", \"type\": \"object\", \"xrefProperties\": [ \"title\", \"description\" ], \"properties\": { \"metadata\": { \"type\": \"object\", \"tags\": [ \"metadata\" ] }, \"uid\": { \"type\": \"string\", \"contentType\": \"uid\" }, \"sections\": { \"type\": \"array\", \"items\": { \"type\": \"object\", \"properties\": { \"children\": { \"type\": \"array\", \"items\": { \"type\": \"object\", \"properties\": { \"href\": { \"type\": \"string\", \"contentType\": \"href\" }, \"text\": { \"type\": \"string\", \"tags\": [ \"localizable\" ] }, \"content\": { \"type\": \"string\", \"contentType\": \"markdown\" } } } }, \"title\": { \"type\": \"string\", \"mergeType\": \"key\" } } } }, \"title\": { \"type\": \"string\" } } } 8. Q & A DocFX fills _global metadata into the processed data model, should the schema reflect this behavior? Decision: NOT include, this schema is for input model, use another schema for output model. Is it necessary to prefix d- to every field that DocFX introduces in? If keep d- Pros: d- makes it straightforward that these keywords are introduced by DocFX Keywords DocFX introduces in will never duplicate with the one preserved by JSON schema Cons: d- prefix provides a hint that these keywords are not first class keywords Little chance that keywords DocFX defines duplicate with what JSON schema defines, after all, JSON schema defines a finite set of reserved keywords. For exampleSwagger spec is also based on JSON schema and the fields it introduces in has no prefix. Decision: Remove d- prefix."
  },
  "spec/docfx_flavored_markdown.html": {
    "href": "spec/docfx_flavored_markdown.html",
    "title": "",
    "keywords": ""
  },
  "spec/metadata_dotnet_spec.html": {
    "href": "spec/metadata_dotnet_spec.html",
    "title": "",
    "keywords": ""
  },
  "spec/metadata_format_spec.html": {
    "href": "spec/metadata_format_spec.html",
    "title": "Doc-as-Code: Metadata Format Specification | docfx",
    "keywords": "Doc-as-Code: Metadata Format Specification 0. Introduction 0.1 Goals and Non-goals The goal of this document is to define a general format to describe language metadata for programming languages. The language metadata is designed to be language agnostic and support multiple programming language in a single metadata file. The main user scenario for language metadata is to generate reference documentation, so this document will discuss how to optimize metadata format for documentation rendering. This document does NOT discuss details of metadata format implementation of a specific programming language. 0.2 Terminology The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL in this document are to be interpreted as described in RFC 2119. Words in italic indicate they are terms previously defined in this document. 1. Items and Identifiers 1.1 Items Item is the basic unit of metadata format. From a documentation perspective, each item represents a \"section\" in the reference documentation. This \"section\" is the minimum unit that you can cross reference to, or customize in layout and content. When implementing the metadata format for your own language, you can decide which elements are items. For example, usually namespaces, classes, and methods are items. However, you can also make smaller elements such as parameters be items if you want them to be referenceable and customizable. Items can be hierarchical. One item can have other items as children. For example, in C#, namespaces and classes can have classes and/or methods as children. 1.2 Identifiers Each item has an identifier (ID) which is unique under its parent. As we're targeting to support multiple languages, there are no restrictions as to which characters are not allowed in identifiers. However, to make identifiers easier to recognize and resolve in Markdown, it's not RECOMMENDED to have whitespaces in identifiers. Markdown processor MAY implement some algorithm to tolerate whitespaces in handwritten Markdown. (Leading and trailing spaces MUST be removed from identifier.) Identifier MUST be treated as case-sensitive when comparing equality. Each item has a unique identifier (UID) which is globally unique. A UID is defined as follows: If an item does not have a parent, its UID is its ID. Otherwise, its UID is the combination of the UID of its parent, a separator and the ID of the item itself. Valid separators are ., :, / and \\. For example, for a class String under namespace System, its ID is String and UID is System.String. Given the above definition, an item's UID MUST starts with the UID of its parent (and any of its ancestors) and ends with the ID of itself. This is useful to quickly determine whether an item is under another item. 1.3 Alias Identifier could be very long, which makes it difficult to write by hand in Markdown. For example, it's easy to create a long ID in C# like this: Format(System.IFormatProvider,System.String,System.Object,System.Object) We can create short alias for items so that they can be referenced easily. Alias is same as ID, except: It doesn't have to be unique. One item can have multiple aliases. It's not RECOMMENDED to create an alias that has nothing to do with an item's ID. Usually an item's alias is part of its ID so it's easy to recognize and memorize. For example, for the case above, we usually create an alias Format(). We can easily get a \"global\" alias for an item by replacing the ID part of its UID with its alias. 2. File Structure 2.1 File Format You can use any file format that can represent structural data to store metadata. However, we recommend using YAML or JSON. In this document, we use YAML in examples, but all YAML can be converted to JSON easily. 2.2 File Layout A metadata file consists of two parts: An \"item\" section and a \"reference\" section. Each section is a list of objects and each object is a key-value pair (hereafter referred to as \"property\") list that represents an item. 2.3 Item Section Though items can be hierarchical, they are flat in an item section. Instead, each item has a \"children\" property indicating its children and a \"parent\" property indicating its parent. An item object has some basic properties: Property Description uid REQUIRED. The unique identifier of the item. children OPTIONAL. A list of UIDs of the item's children. Can be omitted if there are no children. parent OPTIONAL. The UID of the item's parent. If omitted, metadata parser will try to figure out its parent from the children information of other items within the same file. Here is an example of a YAML format metadata file for C# Object class: items: - uid: System.Object parent: System children: - System.Object.Object() - System.Object.Equals(System.Object) - System.Object.Equals(System.Object,System.Object) - System.Object.Finalize() - System.Object.GetHashCode() - System.Object.GetType() - System.Object.MemberwiseClone() - System.Object.ReferenceEquals() - System.Object.ToString() - uid: System.Object.Object() parent: System.Object - uid: System.Object.Equals(System.Object) parent: System.Object - uid: System.Object.Equals(System.Object,System.Object) parent: System.Object - uid: System.Object.Finalize() parent: System.Object - uid: System.Object.GetHashCode() parent: System.Object - uid: System.Object.GetType() parent: System.Object - uid: System.Object.MemberwiseClone() parent: System.Object - uid: System.Object.ReferenceEquals() parent: System.Object - uid: System.Object.ToString() parent: System.Object references: ... Items SHOULD be organized based upon how they will display in documentation. For example, if you want all members of a class be displayed in a single page, put all members in a single metadata file. 2.3 Item Object In additional to the properties listed in last section, item object also has some OPTIONAL properties: Property Description id The identifier of the item. alias A list of aliases of the item. name The display name of the item. fullName The full display name of the item. In programming languages, it's usually the full qualified name. type The type of the item, such as class, method, etc. url If it's a relative URL, then it's another metadata file that defines the item. If it's an absolute URL, it means the item is coming from an external library, and the URL is the documentation page of this item. If omitted, the URL is the location of the current file. source The source code information of the item. It's an object that contains following properties: 1. repo: the remote Git repository of the source code. 2. branch: the branch of the source code. 3. revision: the Git revision of the source code. 4. path: the path to the source code file where the item is defined. 5. startLine: the start line of the item definition. 6. endLine: the end line of the item definition. Here is an example of a C# Dictionary class: - uid: System.Collections.Generic.Dictionary`2 id: Dictionary`2 alias: - Dictionary parent: System.Collections.Generic name: Dictionary<TKey, TValue> fullName: System.Collections.Generic.Dictionary<TKey, TValue> type: class url: System.Collections.Generic.Dictionary`2.yml source: repo: https://github.com/dotnet/netfx.git branch: master revision: 5ed47001acfb284a301260271f7d36d2bb014432 path: src/system/collections/generic/dictionary.cs startLine: 1 endLine: 100 2.4 Custom Properties Besides the predefined properties, item can have its own properties. One restriction is property name MUST NOT contains dots, as dot in property name will have special meaning (described in later section). 2.5 Reference Section The reference section also contains a list of items. These items serve as the references to items in the item section and won't show up in documentation. Also, a reference item doesn't need to have full properties, it just contains necessary information needed by its referrer (for example, name or URL). In metadata file, all items MUST be referenced by UID. It's RECOMMENDED to include all referenced items in reference section. This makes the file self-contained and easy to render at runtime. Many programming languages have the concept of \"template instantiation\". For example, in C#, you can create a new type List<int> from List<T> with argument int. You can create a reference for \"template instances\". For example, for a class inherited from List<int>: items: - uid: NumberList inherits: - System.Collections.Generic.List<System.Int32> references: - uid: System.Collections.Generic.List`1<System.Int32> link: @\"System.Collections.Generic.List`1\"<@\"System.Int32\"> - uid: System.Collections.Generic.List`1 name: List url: system.collections.generic.list`1.yml - uid: System.Int32 name: int url: system.int32.yml 2.6 Multiple Language Support An item may need to support multiple languages. For example, in .NET, a class can be used in C#, VB, managed C++ and F#. Different languages may have differences in properties. For example, a list of string is displayed as List<string> in C#, while List(Of string) in VB. To support this scenario, we introduce a concept of language context to allow defining different property values in different languages. If a property name is in the form of property_name.language_name, it defines the value of property_name under language_name. For example: - uid: System.Collections.Generic.Dictionary`2 name.csharp: Dictionary<TKey, TValue> name.vb: Dictionary(Of TKey, TValue) This means the name of dictionary is Dictionary<TKey, TValue> in C# and Dictionary(Of TKey, TValue) in VB. The following properties SHALL NOT be overridden in language context: uid, id, alias, children, and parent. 3. Work with Metadata in Markdown 3.1 YAML Metadata Section In a Markdown file, you can also define items using the same metadata syntax. The metadata definition MUST be in YAML format and enclosed by triple-dash lines (---). Here is an example: --- uid: System.String summary: String class --- This is a **string** class. You can have multiple YAML sections inside a single Markdown file, but in a single YAML section, there MUST be only one item. The YAML metadata section does not have to contain all properties. The only property that MUST appear is \"uid\", which is used to match the same item in metadata file. The most common scenario for using YAML section is to specify which item the markdown doc belongs to. But you can also overwrite item property by defining one with the same name in YAML section. In the above example, the property \"summary\" will overwrite the same one in metadata. As with language context, the following properties SHALL NOT be overridden: uid, id, alias, children, and parent. You SHALL NOT define new item in Markdown. 3.2 Reference Items in Markdown To cross reference an item, you can use URI with xref scheme. You can either use standard link or automatic link with the above URI. For example, to cross reference System.String: [System.String](xref:System.String) <xref:System.String> Since item reference is a URI, special characters (like #, ?) MUST be encoded. We also introduce a shorthand markdown syntax to cross reference easily: If a string starts with @, and followed by a string enclosed by quotes ' or double quotes \", it will be treated as an item reference. The string inside \"\" or '' is the UID of the item. Here is one example: @\"System.String\" Markdown processor MAY implement some algorithm to allow omit curly braces if ID is simple enough. For example, For reference like @\"int\", we may also want to allow @int. When rendering references in Markdown, they will expand into a link with the item's name as link title. You can also customize the link title using the standard syntax of Markdown: [Dictionary](xref:System.Collections.Generic.Dictionary`2)<[String](xref:System.String), [String](xref:System.String)> Will be rendered to: Dictionary<String, String> Besides UID, we also allow referencing items using ID and alias, in the Markdown processor, the below algorithm SHOULD be implemented to resolve references. Check whether the reference matches: Any identifier of current item's children. Any alias of current item's children. Any identifier of current item's silbings. Any alias of current item's silbings. A UID. A global alias."
  },
  "spec/sdp_design_spec.html": {
    "href": "spec/sdp_design_spec.html",
    "title": "Schema-driven Document Processor(SDP) Design Spec | docfx",
    "keywords": "Schema-driven Document Processor(SDP) Design Spec 1. Overview DocFX supports different document processors to handle different kinds of input. With a new data model introduced in, a new document processor is required to support that model, even most of the code logic is the same for these processors. With this situation considered, a Schema-driven Document Processor (abbreviated to SDP below) is introduced to simplify the process. Togethor with a well defined DocFX Document Schema, SDP is able to validate and process a new data model with no extra effort needed. 2. Workflow The workflow for SDP is illustrated below. In general, the schema file, with suggested naming convention, has documentType in its name, as {documentType}.schema.json (When title is defined in the schema file, title is considered as the documentType for this schema). docfx loads the schema files from schemas subfolder in template folder, and creates processors for these schema files with per schema file per processor. With data models are processed, docfx applies templates for that documentType to these data model, as details illustrated in Template Introduction and generates output documentation."
  },
  "spec/triple_slash_comments_spec.html": {
    "href": "spec/triple_slash_comments_spec.html",
    "title": "",
    "keywords": ""
  },
  "tutorial/advanced_support_hyperlink.html": {
    "href": "tutorial/advanced_support_hyperlink.html",
    "title": "🔧 Advanced: Support Hyperlink | docfx",
    "keywords": "🔧 Advanced: Support Hyperlink In this topic, we will support hyperlinking in rtf files. Create a hyperlink in the rtf file: Open foo.rtf by Word. Add a hyperlink in content Set the link target to an existing bar.rtf Save the document. About link An author can write any valid hyperlink in the document, and then needs to run DocFX build to update file links. What is file link: The hyperlink must be a relative path and not rooted. valid: foo\\bar.rtf, ../foobar.rtf invalid: /foo.rtf, c:\\foo\\bar.rtf, http://foo.bar/, mailto:foo@bar.foobar The file must exist. Why update file link: The story is: In foo.rtf, it has a file link to bar.rtf. In document build, bar.rtf generates a file with the name bar.html. But in foo.rtf, the link target is still bar.rtf, thus in the output folder we cannot find this file and we will get a broken link. To resolve the broken link, we need to update the link target from bar.rtf to bar.html. File link is a relative path, but we cannot track the relative path easily. So we track the normalized file path instead. What is a normalized file path: It always starts from the working folder (the folder that contains docfx.json), and we write it as ~/. No ../ or ./ or // Replace \\ with /. No url encoding. The path must be same as it in the file system. No anchor. Finally, a valid normalized file path looks like: ~/foo/bar.rtf. Pros Same form in different documents when the target is the same file. When file structure is: z:\\a\\b\\foo.rtf z:\\a\\b\\c\\bar.rtf z:\\a\\b\\c\\foobar.rtf Link target c/foobar.rtf in foo.rtf and link target foobar.rtf in bar.rtf is the same file. When the working folder is z:\\a\\, the link target is always ~/b/c/foobar.rtf. Avoids differences in style when referring to the same file. For example, the following hyperlinks target the same file: a/foo.rtf, ./a/foo.rtf, a/b/../foo.rtf, a//foo.rtf, a\\foo.rtf Cons A folder with the name ~ is not supported. Prepare Open the rtf plug-in library project in Visual Studio. Add nuget packages: for plug-in: Microsoft.DocAsCode.Utility Add framework assembly reference: System.Core, System.Web, System.Xml.Linq Update rtf document processor Following the rules for hyperlink, add a FixLink help method: private static void FixLink(XAttribute link, RelativePath filePath, HashSet<string> linkToFiles) { string linkFile; string anchor = null; if (PathUtility.IsRelativePath(link.Value)) { var index = link.Value.IndexOf('#'); if (index == -1) { linkFile = link.Value; } else if (index == 0) { return; } else { linkFile = link.Value.Remove(index); anchor = link.Value.Substring(index); } var path = filePath + (RelativePath)linkFile; var file = (string)path.GetPathFromWorkingFolder(); link.Value = file + anchor; linkToFiles.Add(HttpUtility.UrlDecode(file)); } } RelativePath helps us generate the links correctly. Then add CollectLinksAndFixDocument method: private static HashSet<string> CollectLinksAndFixDocument(FileModel model) { string content = (string)((Dictionary<string, object>)model.Content)[\"conceptual\"]; var doc = XDocument.Parse(content); var links = from attr in doc.Descendants().Attributes() where \"href\".Equals(attr.Name.LocalName, StringComparison.OrdinalIgnoreCase) || \"src\".Equals(attr.Name.LocalName, StringComparison.OrdinalIgnoreCase) select attr; var path = (RelativePath)model.File; var linkToFiles = new HashSet<string>(); foreach (var link in links) { FixLink(link, path, linkToFiles); } using (var sw = new StringWriter()) { doc.Save(sw); ((Dictionary<string, object>)model.Content)[\"conceptual\"] = sw.ToString(); } return linkToFiles; } Modify Save method with report links: public SaveResult Save(FileModel model) { HashSet<string> linkToFiles = CollectLinksAndFixDocument(model); return new SaveResult { DocumentType = \"Conceptual\", ModelFile = model.File, LinkToFiles = linkToFiles.ToImmutableArray(), }; } View final RtfDocumentProcessor.cs Test and verify Build project. Copy dll to Plugins folder. Modify rtf file, create hyperlink, link to another rtf file, and save. Build with command DocFX build. Verify output html file."
  },
  "tutorial/docfx_getting_started.html": {
    "href": "tutorial/docfx_getting_started.html",
    "title": "",
    "keywords": ""
  },
  "tutorial/docfx.exe_user_manual.html": {
    "href": "tutorial/docfx.exe_user_manual.html",
    "title": "docfx.exe User Manual | docfx",
    "keywords": "Doc-as-code: docfx.exe User Manual 0. Introduction docfx.exe is used to generate documentation for programs. It has the ability to: Extract language metadata for programing languages as defined in Metadata Format Specification. Currently C#, VB and F# are supported. The language metadata will be saved with YAML format as described in YAML 1.2. Look for available conceptual files as provided and link it with existing programs with syntax described in Section 3. Work with Metadata in Markdown. Supported conceptual files are plain text files, html files, and markdown files. Generate documentation to a. Visualize language metadata, with extra content provided by linked conceptual files using syntax described in Section 3. Work with Metadata in Markdown. b. Organize and render available conceptual files. It can be easily cross-referenced with language metadata pages. We support Docfx Flavored Markdown(DFM) for writing conceptual files. DFM supports all Github Flavored Markdown(GFM) syntax with 2 exceptions when resolving list. It also adds several new features including file inclusion, cross reference, and yaml header. For detailed description about DFM, please refer to DFM. Currently generating documentations to a client only website is supported. The generated website can be easily published to whatever platform such as Github Pages and Azure Website with no extra effort. Generating offline documentation such as PDF is also supported now. 1. Syntax docfx <command> [<args>] 2. Commands 2.0 Init command docfx init docfx init helps generate an docfx.json file. 2.1 Help command docfx help docfx help -a list available subcommands. docfx help <command> to read about a specific subcommand 2.2 Extract language metadata command docfx metadata Syntax docfx metadata [<projects>] [--property <n1>=<v1>;<n2>=<v2>] Layout |-- <metadata folder> |-- api | |-- <namespace>.yml | |-- <class>.yml |-- toc.yml |-- index.yml 2.2.1 Optional <projects> argument <projects> specifies the projects to have metadata extracted. There are several approaches to extract language metadata. From a supported file or file list Supported file extensions include .csproj, .vbproj, .sln, project.json, dll assembly file, .cs source file and .vb source file. Multiple files are separated by whitespace, e.g. docfx metadata Class1.cs a.csproj Note Glob pattern is NOT supported in command line options. From docfx.json file, as described in Section3. If the argument is not specified, docfx.exe will try reading docfx.json under current directory. The default output folder is _site/ folder if it is not specified in docfx.json under current directory. 2.2.2 Command option --shouldSkipMarkup If adding option --shouldSkipMarkup in metadata command, it means that DocFX would not render triple-slash-comments in source code as markdown. e.g. docfx metadata --shouldSkipMarkup 2.2.3 Command option --property <n1>=<v1>;<n2>=<v2> An optional set of MSBuild properties used when interpreting project files. These are the same properties that are passed to msbuild via the /property: = ; = command line argument. For example: docfx metadata --property TargetFramework=net46 generates metadata files with .NET framework 4.6. This command can be used when the project supports multiple TargetFrameworks. 2.3 Generate documentation command docfx build Syntax docfx build [-o:<output_path>] [-t:<template folder>] docfx build generates documentation for current folder. If toc.yml or toc.md is found in current folder, it will be rendered as the top level TABLE-OF-CONTENT. As in website, it will be rendered as the top navigation bar. Path in toc.yml or toc.md are relative to the TOC file. Note Please note that homepage is not supported in toc.md. And if href is referencing to a folder, it must end with /. toc.yml syntax toc.yml is an array of items. Each item can have following properties: Property Description name Required. The title of the navigation page. href Required. Can be a folder or a file UNDER current folder. A folder must end with /. In case of a folder, TOC.md inside the folder will be rendered as second level TABLE-OF-CONTENT. As in website, it will be rendered as a sidebar. homepage The default content shown when no article is selected. TOC.yml Sample - name: Home href: articles/Home.md - name: Roslyn Wiki href: roslyn_wiki/ - name: Roslyn API href: api_roslyn/ homepage: homepages/roslyn_language_features.md TOC.md Sample ## [Home](articles/Home.md) ## [Roslyn Wiki](roslyn_wiki/) ## [Roslyn API](api_roslyn/) 2.3.1 Optional <output_path> argument The default output folder is _site/ folder 2.3.2 Optional <template folder> argument If specified, use the template from template folder Template Folder Structure |-- <template folder> |-- index.html |-- styles | |-- docascode.css | |-- docascode.js |-- template | |-- toc.html | |-- navbar.html | |-- yamlContent.html |-- favicon.ico |-- logo.ico 2.4 Generate PDF documentation command docfx pdf Syntax docfx pdf [<config_file_path>] [-o:<output_path>] docfx pdf generates PDF for the files defined in config file, if config file is not specified, docfx tries to find and use docfx.json file under current folder. Note Prerequisite: We leverage wkhtmltopdf to generate PDF. Download wkhtmltopdf and save the executable folder path to %PATH%. Or just install wkhtmltopdf using chocolatey: choco install wkhtmltopdf Current design is that each TOC file generates a corresponding PDF file. Walk through Walkthrough: Generate PDF Files to get start. If cover.md is found in a folder, it will be rendered as the cover page. 3. docfx.json Format Top level docfx.json structure is key-value pair. key is the name of the subcommand, current supported subcommands are metadata and build. 3.1 Properties for metadata Metadata section defines an array of source projects and their output folder. Each item has src and dest property. src defines the source projects to have metadata generated, which is in File Mapping Format. Detailed syntax is described in 4. Supported name-files File Mapping Format below. dest defines the output folder of the generated metadata files. Key Description src Defines the source projects to have metadata generated, which is in File Mapping Format. Relative paths are relative to the docfx.json file being used. To go up a folder use ../. dest Defines the output folder of the generated metadata files. Relative paths are relative to the docfx.json file being used. To go up a folder use ../. shouldSkipMarkup If set to true, DocFX would not render triple-slash-comments in source code as markdown. filter Defines the filter configuration file, please go to How to filter out unwanted apis attributes for more details. useCompatibilityFileName If set to true, DocFX would keep ` in comment id instead of replacing it with -. properties Defines an optional set of MSBuild properties used when interpreting project files. These are the same properties that are passed to msbuild via the /property:name=value command line argument. Sample { \"metadata\": [ { \"src\": [ { \"files\": [\"**/*.csproj\"], \"exclude\": [ \"**/bin/**\", \"**/obj/**\" ], \"src\": \"../src\" } ], \"dest\": \"obj/docfx/api/dotnet\", \"shouldSkipMarkup\": true, \"properties\": { \"TargetFramework\": \"netstandard1.3\" } }, { \"src\": [ { \"files\": [\"**/*.js\"], \"src\": \"../src\" } ], \"dest\": \"obj/docfx/api/js\", \"useCompatibilityFileName\": true, \"properties\": { \"TargetFramework\": \"net46\" } } ] } Note Make sure to specify \"TargetFramework\": <one of the frameworks> in your docfx.json when the project is targeting for multiple platforms. 3.2 Properties for build Key Description content Contains all the files to generate documentation, including metadata yml files and conceptual md files. name-files file mapping with several ways to define it, as to be described in Section4. The files contains all the project files to have API generated. resource Contains all the resource files that conceptual and metadata files dependent on, e.g. image files. name-files file mapping with several ways to define it, as to be described in Section4. overwrite Contains all the conceptual files which contains yaml header with uid and is intended to override the existing metadata yml files. name-files file mapping with several ways to define it, as to be described in Section4. globalMetadata Contains metadata that will be applied to every file, in key-value pair format. For example, you can define \"_appTitle\": \"This is the title\" in this section, and when applying template default, it will be part of the page title as defined in the template. fileMetadata Contains metadata that will be applied to specific files. name-files file mapping with several ways to define it, as to be described in Section4. globalMetadataFiles Specify a list of JSON file path containing globalMetadata settings, as similar to {\"key\":\"value\"}. Please read Section3.2.3 for detail. fileMetadataFiles Specify a list of JSON file path containing fileMetadata settings, as similar to {\"key\":\"value\"}. Please read Section3.2.3 for detail. template The templates applied to each file in the documentation. It can be a string or an array. The latter ones will override the former ones if the name of the file inside the template collides. If omitted, embedded default template will be used. theme The themes applied to the documentation. Theme is used to customize the styles generated by template. It can be a string or an array. The latter ones will override the former ones if the name of the file inside the template collides. If omitted, no theme will be applied, the default theme inside the template will be used. xref Specifies the urls of xrefmap used by content files. Currently, it supports following scheme: http, https, ftp, file, embedded. xrefService Specifies the url patterns of xref service. Please read Section3.2.4 for detail. exportRawModel If set to true, data model to run template script will be extracted in .raw.json extension. rawModelOutputFolder Specify the output folder for the raw model. If not set, the raw model will be generated to the same folder as the output documentation. exportViewModel If set to true, data model to apply template will be extracted in .view.json extension. viewModelOutputFolder Specify the output folder for the view model. If not set, the view model will be generated to the same folder as the output documentation. dryRun If set to true, template will not be actually applied to the documents. This option is always used with --exportRawModel or --exportViewModel, so that only raw model files or view model files are generated. maxParallelism Set the max parallelism, 0 (default) is same as the count of CPU cores. markdownEngineName Set the name of markdown engine, default is dfm, other available engines are gfm and markdig. markdownEngineProperties Set the parameters for markdown engine, value should be a JSON string. noLangKeyword Disable default lang keyword, it can be downloaded from here. keepFileLink If set to true, docfx does not dereference (aka. copy) file to the output folder, instead, it saves a link_to_path property inside manifest.json to indicate the physical location of that file. A file link will be created by incremental build and copy resource file. sitemap In format SitemapOptions Specifies the options for the sitemap.xml file. disableGitFeatures Disable fetching Git related information for articles. Set to true if fetching git related information is slow for huge Git repositories. Default value is false. 3.2.1 Templates and Themes Templates are used to transform YAML files generated by docfx to human-readable pages. A page can be a markdown file, a html file or even a plain text file. Each YAML file will be transformed to ONE page and be exported to the output folder preserving its relative path to src. For example, if pages are in HTML format, a static website will be generated in the output folder. Theme is to provide general styles for all the generated pages. Files inside a theme will be generally COPIED to the output folder. A typical usage is, after YAML files are transformed to HTML pages, well-designed CSS style files in a Theme can then overwrite the default styles defined in template, e.g. main.css. There are two ways to use custom templates and themes. To use a custom template, one way is to specify template path with --template (or -t) command option, multiple templates must be separated by , with no spaces. The other way is to set key-value mapping in docfx.json: { ... { \"build\" : { ... \"template\": \"custom\", ... } ... } { ... { \"build\" : { ... \"template\": [\"default\", \"X:/template/custom\"], ... } ... } Note The template path could either be a zip file called <template>.zip or a folder called <template>. Warning DocFX has embedded templates: default, default(zh-cn), pdf.default, statictoc and common. Please avoid using these as template folder name. To custom theme, one way is to specify theme name with --theme command option, multiple themes must be separated by , with no spaces. The other way is to set key-value mapping in docfx.json as similar to defining template. Also, both .zip file and folder are supported. Please refer to How to Create Custom Templates to create custom templates. Sample { \"build\": { \"content\": [ { \"files\": [\"**/*.yml\"], \"src\": \"obj/docfx\" }, { \"files\": [\"tutorial/**/*.md\", \"spec/**/*.md\", \"spec/**/toc.yml\"] }, { \"files\": [\"toc.yml\"] } ], \"resource\": [ { \"files\": [\"spec/images/**\"] } ], \"overwrite\": \"apispec/*.md\", \"externalReference\": [ ], \"globalMetadata\": { \"_appTitle\": \"DocFX website\", \"_gitContribute\": { \"repo\": \"https://github.com/org/repo\", \"branch\": \"dev\", \"apiSpecFolder\": \"docs-ref-overwrite\" } }, \"dest\": \"_site\", \"template\": \"default\" } } 3.2.2 Reserved Metadata After passing values through global metadata or file metadata, DocFX can use these metadata in templates to control the output html. Reserved metadatas: Metadata Name Type Description _appTitle string Will be appended to each output page's head title. _appFooter string The footer text. Will show DocFX's Copyright text if not specified. _appLogoPath string Logo file's path from output root. Will show DocFX's logo if not specified. Remember to add file to resource. _appFaviconPath string Favicon file's path from output root. Will show DocFX's favicon if not specified. Remember to add file to resource. _enableSearch bool Indicate whether to show the search box on the top of page. _enableNewTab bool Indicate whether to open a new tab when clicking an external link. (internal link always shows within the current tab) _disableNavbar bool Indicate whether to show the navigation bar on the top of page. _disableBreadcrumb bool Indicate whether to show breadcrumb on the top of page. _disableToc bool Indicate whether to show table of contents on the left of page. _disableAffix bool Indicate whether to show the affix bar on the right of page. _disableContribution bool Indicate whether to show the View Source and Improve this Doc buttons. _gitContribute object Customize the Improve this Doc URL button for public contributors. Use repo to specify the contribution repository URL. Use branch to specify the contribution branch. Use apiSpecFolder to specify the folder for new overwrite files. If not set, the git URL and branch of the current git repository will be used. _gitUrlPattern string Choose the URL pattern of the generated link for View Source and Improve this Doc. Supports github and vso currently. If not set, DocFX will try speculating the pattern from domain name of the git URL. _noindex bool File(s) specified are not returned in search results 3.2.3 Separated metadata files for global metadata and file metadata There're three ways to set metadata for a file in DocFX: using global metadata, it will set metadata for every file. using file metadata, it will set metadata for files that match pattern. using YAML header, it will set metadata for current file. In above ways, the later way will always overwrite the former way if the same key of metadata is set. Here we will show you how to set global metadata and file metadata using separated metadata files. Take global metadata for example, you can set globalMetadataFiles in docfx.json or --globalMetadataFiles in build command line. The usage of fileMetadataFiles is the same as globalMetadataFiles. There're some metadata file examples: globalMetadata file example { \"_appTitle\": \"DocFX website\", \"_enableSearch\": \"true\" } fileMetadata file example { \"priority\": { \"**.md\": 2.5, \"spec/**.md\": 3 }, \"keywords\": { \"obj/docfx/**\": [\"API\", \"Reference\"], \"spec/**.md\": [\"Spec\", \"Conceptual\"] }, _noindex: { \"articles/**/article.md\": true } } There're some examples about how to use separated metadata files. use globalMetadataFiles in docfx.json ... \"globalMetadataFiles\": [\"global1.json\", \"global2.json\"], ... use --globalMetadataFiles in build command line docfx build --globalMetadataFiles global1.json,global2.json use fileMetadataFiles in docfx.json ... \"fileMetadataFiles\": [\"file1.json\", \"file2.json\"], ... use --fileMetadataFiles in build command line docfx build --fileMetadataFiles file1.json,file2.json Note that, metadata set in command line will merge with metadata set in docfx.json. If same key for global metadata was set, the order to be overwritten would be(the later one will overwrite the former one): global metadata from docfx config file global metadata from global metadata files global metadata from command line If same file pattern for file metadata was set, the order to be overwritten would be(the later one will overwrite the former one): file metadata from docfx config file file metadata from file metadata files Given multiple metadata files, the behavior would be undetermined, if same key is set in these files. 3.2.4 Xref service url pattern Xref service url pattern will exact url by following steps: Replace environment variables. Syntax: {%variableName%} Process: load variable value from enviroment variables, replace the source content. Extract post pipelines. Syntax: |> pipelineName parameter1 parameter2 ... Process: load pipeline, and extract parameters, remove from url. Current pipeline only contains: removeHost, addQueryString, pluggable pipeline will be add later. Runtime replace variables. Syntax: {varName} Process: replace the source content to the value of variable (uri data encoded). e.g.: Environment variables: test = hello Available Pipeline: removeHost Variable: uid = testuid1 Url pattern: http://{%test%}.contoso.com/?uid={uid}|> removeHost It will run as following steps: Replace environment variables, http://hello.contoso.com/?uid={uid}|> removeHost. Extract post pipelines, http://hello.contoso.com/?uid={uid}, and append a post pipeline removeHost. Runtime replace variables, http://hello.contoso.com/?uid=testuid. Send request to http://hello.contoso.com/?uid=testuid, and get response from site. Run post pipeline removeHost. 3.2.5 SitemapOptions The SitemapOptions is to configure the values for generating sitemap.xml file. Property Name Type Description baseUrl string Specifies the base url for the website to be published. It MUST begin with the protocol (such as http) and end with a trailing slash. For example, https://dotnet.github.io/docfx/. If the value is not specified, sitemap.xml will NOT be generated. lastmod DateTime Specifies the date of last modification of the file. If not specified, docfx automatically set the value to the time the file is built. changefreq enum Specifies the value of changefreq in sitemap.xml. Valid values are always, hourly, daily, weekly, monthly, yearly, never. If not specified, the default value is daily priority double Specifies the value of priority in sitemap.xml. Valid values between 0.0 and 1.0. If not specified, the default value is 0.5 fileOptions SitemapOptions Optional. This property can be used when some specific files have different sitemap settings. It is a set of key-value pairs, where key is the glob pattern for input files, and value is the sitemap options. Order matters and the latter matching option overwrites the former ones. In the following sample settings, the yml files inside api folder are with priority 0.3 while Markdown files are with priority 0.8 and with a different baseUrl. Sample settings: \"build\": { \"sitemap\":{ \"baseUrl\": \"https://dotnet.github.io/docfx\", \"priority\": 0.1, \"changefreq\": \"monthly\", \"fileOptions\":{ \"**/api/**.yml\": { \"priority\": 0.3, \"lastmod\": \"2001-01-01\", }, \"**/GettingStarted.md\": { \"baseUrl\": \"https://dotnet.github.io/docfx/conceptual\", \"priority\": 0.8, \"changefreq\": \"daily\" } } } } Possible generated sitemap.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"> <url> <loc>https://dotnet.github.io/docfx/api/System.String.html</loc> <lastmod>2001-01-01T00:00:00.00+08:00</lastmod> <changefreq>monthly</changefreq> <priority>0.3</priority> </url> <url> <loc>https://dotnet.github.io/docfx/conceptual/GettingStarted.html</loc> <lastmod>2017-09-21T10:00:00.00+08:00</lastmod> <changefreq>daily</changefreq> <priority>0.3</priority> </url> <url> <loc>https://dotnet.github.io/docfx/ReadMe.html</loc> <lastmod>2017-09-21T10:00:00.00+08:00</lastmod> <changefreq>monthly</changefreq> <priority>0.1</priority> </url> </urlset> 3.3 Properties for pdf pdf supports ALL the properties for build, besides that, the following table lists additional properties specified for pdf only. Key Description name Specifies the prefix of the generated PDF files, e.g. PDF generated from testproject\\toc.yml is named as {name}.pdf, testproject\\api\\toc.yml is named as {name}_api.pdf. If not specified, the value of name is the folder name testproject. generatesAppendices If specified, an appendices.pdf file is generated containing all the not-in-TOC articles. keepRawFiles If specified, the intermediate html files used to generate the PDF are not deleted after the PDF has been generated. wkhtmltopdf Contains additional options specific to wkhtmltopdf which is used internally to generate the PDF files. coverTitle The name of the bookmark to use for the cover page. If omitted, \"Cover Page\" will be used. tocTitle The name of the bookmark to use for the \"Table of Contents\". If omitted, \"Table of Contents\" will be used. outline The type of outline to use. Valid values are NoOutline, DefaultOutline, WkDefaultOutline. If not specified, the default value is DefaultOutline. If WkDefaultOutline is specified, --outline is passed to wkhtmltopdf; otherwise --no-outline is passed to wkhtmltopdf. noStdin Do not use --read-args-from-stdin for the wkhtmltopdf. Html input file names are set using the command line. It has been introduced to use in the Azure pipeline build. Can cause maximum allowed arguments length overflow if too many input parts (like Appendices, TocTitle, CoverPageTitle) were set for certain html source file. excludeDefaultToc If true, excludes the table of contents (generated by DocFX) in the PDF file. 3.3.1 Properties for the wkhtmltopdf Key Key Description filePath The path and file name of a wkhtmltopdf.exe compatible executable. additionalArguments Additional arguments that should be passed to the wkhtmltopdf executable. For example, pass --enable-local-file-access if you are building on a local file system. This will ensure that the supporting *.js and *.css files are loaded when rendering the HTML being converted to PDF. 4. Supported File Mapping Format There are several ways to define file mapping. 4.1 Array Format This form supports multiple file mappings, and also allows additional properties per mapping. Supported properties: Property Name Description files REQUIRED. The file or file array, glob pattern is supported. name Obsoleted, please use dest. exclude The files to be excluded, glob pattern is supported. cwd Obsoleted, please use src. src Specifies the source directory. If omitted, the directory of the config file will be used. It is possible to set this path relative or absolute. Use the relative path defintion when you want to refer to files in relative folders while want to keep folder structure. e.g. set src to ... When you prefere absolut path, maybe it is more meaningful to use System Enviroment variables. dest The folder name for the generated files. version Version name for the current file mapping. If not set, treat the current file-mapping item as in default version. Mappings with the same version name will be built together. Cross reference doesn't support cross different versions. caseSensitive TOBEIMPLEMENTED. Default value is false. If set to true, the glob pattern is case sensitive. e.g. *.txt will not match 1.TXT. For OS Windows, file path is case insensitive while for Linux/Unix, file path is case sensitive. This option offers user the flexibility to determine how to search files. supportBackslash TOBEIMPLEMENTED. Default value is true. If set to true, \\ will be considered as file path separator. Otherwise, \\ will be considered as normal character if escape is set to true and as escape character if escape is set to false. If escape is set to true, \\\\ should be used to represent file path separator. escape TOBEIMPLEMENTED. Default value is false. If set to true, \\ character is used as escape character, e.g. \\{\\}.txt will match {}.txt. \"key\": [ {\"files\": [\"file1\", \"file2\"], \"dest\": \"dest1\"}, {\"files\": \"file3\", \"dest\": \"dest2\"}, {\"files\": [\"file4\", \"file5\"], \"exclude\": [\"file5\"], \"src\": \"folder1\"}, {\"files\": \"Example.yml\", \"src\": \"v1.0\", \"dest\":\"v1.0/api\", \"version\": \"v1.0\"}, {\"files\": \"Example.yml\", \"src\": \"v2.0\", \"dest\":\"v2.0/api\", \"version\": \"v2.0\"} ] 4.2 Compact Format \"key\": [\"file1\", \"file2\"] 4.3 Glob Pattern DocFX uses Glob to support glob pattern in file path. It offers several options to determine how to parse the Glob pattern: caseSensitive: Default value is false. If set to true, the glob pattern is case sensitive. e.g. *.txt will not match 1.TXT. For OS Windows, file path is case insensitive while for Linux/Unix, file path is case sensitive. This option offers user the flexibility to determine how to search files. supportBackslash: Default value is true. If set to true, \\ will be considered as file path separator. Otherwise, \\ will be considered as normal character if escape is set to true and as escape character if escape is set to false. If escape is set to true, \\\\ should be used to represent file path separator. escape: Default value is false. If set to true, \\ character is used as escape character, e.g. \\{\\}.txt will match {}.txt. In general, the glob pattern contains the following rules: * matches any number of characters, but not / ? matches a single character, but not / ** matches any number of characters, including /, as long as it's the only thing in a path part {} allows for a comma-separated list of OR expressions SAMPLES 5. Q & A Do we support files outside current project folder(the folder where docfx.json exists)? A: YES. DO specify src and files outside of current folder will be copied to output folder keeping the same relative path to src. Do we support output folder outside current project folder(the folder where docfx.json exists)? A: YES. Do we support referencing files outside of current project folder(the folder where docfx.json exists)? A: NO."
  },
  "tutorial/howto_add_a_customized_post_processor.html": {
    "href": "tutorial/howto_add_a_customized_post_processor.html",
    "title": "How-to: Add a customized post-processor | docfx",
    "keywords": "How-to: Add a customized post-processor We provide the ability to process output files by adding a customized post-processor. In DocFX, the index file for full-text-search is generated by one post-processor named ExtractSearchIndex. In this topic, we will show how to add a customized post-processor. Step0: Preparation Create a new C# class library project in Visual Studio. Add nuget packages: System.Collections.Immutable with version 1.3.1 Microsoft.Composition with version 1.0.31 Add Microsoft.DocAsCode.Plugins If you are building DocFX from source code, add this reference to the project, otherwise add the nuget package Microsoft.DocAsCode.Plugins with the same version as DocFX. Step1: Create a new class (MyProcessor.cs) with the following code: [Export(nameof(MyProcessor), typeof(IPostProcessor))] public class MyProcessor : IPostProcessor { // TODO: implements IPostProcessor } Step2: Update global metadata public ImmutableDictionary<string, object> PrepareMetadata(ImmutableDictionary<string, object> metadata) { // TODO: add/remove/update property from global metadata return metadata; } In this method, we can update the global metadata before building all the files declared in docfx.json. Otherwise, you can just return the metadata from parameters if you don't need to change global metadata. Using ExtractSearchIndex for example, we add \"_enableSearch\": true in global metadata. The default template would then know it should load a search box in the navbar. Step3: Process all the files generated by DocFX public Manifest Process(Manifest manifest, string outputFolder) { // TODO: add/remove/update all the files included in manifest return manifest; } Input for the method manifest contains a list of all files to process, and outputFolder specifies the output folder where our static website will be placed. We can implement customized operations here to process all files generated by DocFX. Note Post-processor aims to process the output files, so the FileModel can't be accessed in this phase. If some metadata is needed here, an option is to save it in FileModel.ManifestProperties in build phase, then access it through ManifestItem.Metadata. Another option is to save it somewhere in output files, like HTML's <meta> Tag. Using ExtractSearchIndex for example again, we traverse all HTML files, extract key words from these HTML files and save a file named index.json under the outputFolder. Finally we return the manifest which is not modified. Step4: Build your project and copy the output dll files to: Global: the folder with name Plugins under DocFX.exe Non-global: the folder with name Plugins under a template folder, then run DocFX build command with parameter -t {template}. Hint: DocFX can merge templates, so we can specify multiple template folders as DocFX build -t {templateForRender},{templateForPlugins}. Each of the template folders should have a subfolder named Plugins with exported assemblies. Step5: Add your post processor in docfx.json In this step, we need to enable the processor by adding its name in docfx.json. Here is an example: { \"build\": { ... \"postProcessors\": [\"OutputPDF\", \"BeautifyHTML\", \"OutputPDF\"] } } As you can see, the postProcessors is an array, which means it could have multiple processors. It needs to be pointed out that the order of postProcessors written in docfx.json is also the order to process output files. In the above example, DocFX will run OutputPDF first, then BeautifyHTML, and then OutputPDF again. If you want to enable the post processors without changing docfx.json, you can use the build command option like docfx build --postProcessors=OutputPDF,BeautifyHTML,OutputPDF. One more thing need to be noted: the build command option postProcessors would override the corresponding configuration in docfx.json."
  },
  "tutorial/howto_build_your_own_type_of_documentation_with_custom_plug-in.html": {
    "href": "tutorial/howto_build_your_own_type_of_documentation_with_custom_plug-in.html",
    "title": "How-to: Build your own type of documentation with a custom plug-in | docfx",
    "keywords": "How-to: Build your own type of documentation with a custom plug-in In this topic we will create a plug-in to convert some simple rich text format files to html documents. Goal and limitation In scope: Our input will be a set of rtf files with .rtf as the file extension name. The rtf files will be built as html document. Out of scope: Picture or other object in rtf files. Hyperlink in rtf files. (in the advanced tutorial, we will describe how to support hyperlinks in a custom plugin.) Metadata and title. Preparation Create a new C# class library project in Visual Studio, targets .NET Framework 4.7.2 or later. Add nuget packages: System.Collections.Immutable with version 1.3.1 or later (if not already included in your .NET Framework target version) Microsoft.Composition with version 1.0.31 Add Microsoft.DocAsCode.Plugins and Microsoft.DocAsCode.Common If building DocFX from source code then add a reference to the project, otherwise add the nuget packages with the same version as DocFX. Add framework assembly references: PresentationCore, PresentationFramework, WindowsBase. (This step is optional in Visual Studio 2017 or above) Add a project for converting rtf to html: Clone project MarkupConverter, and reference it. Copy the code file CSharp/parallel/ParallelExtensionsExtras/TaskSchedulers/StaTaskScheduler.cs from DotNet Samples Create a document processor Responsibility of the document processor Declare which file can be handled. Load from the file to the object model. Provide build steps. Report document type, file links and xref links in document. Update references. Create our RtfDocumentProcessor Create a new class (RtfDocumentProcessor.cs) with the following code: [Export(typeof(IDocumentProcessor))] public class RtfDocumentProcessor : IDocumentProcessor { // todo : implements IDocumentProcessor. } Declare that we can handle the .rtf file: public ProcessingPriority GetProcessingPriority(FileAndType file) { if (file.Type == DocumentType.Article && \".rtf\".Equals(Path.GetExtension(file.File), StringComparison.OrdinalIgnoreCase)) { return ProcessingPriority.Normal; } return ProcessingPriority.NotSupported; } Here we declare this processor can handle any .rtf file in the article category with normal priority. When two or more processors compete for the same file, DocFX will give it to the higher priority one. Unexpected: two or more processor declare for the same file with same priority. Load our rtf file by reading all text: public FileModel Load(FileAndType file, ImmutableDictionary<string, object> metadata) { var content = new Dictionary<string, object> { [\"conceptual\"] = File.ReadAllText(Path.Combine(file.BaseDir, file.File)), [\"type\"] = \"Conceptual\", [\"path\"] = file.File, }; var localPathFromRoot = PathUtility.MakeRelativePath(EnvironmentContext.BaseDirectory, EnvironmentContext.FileAbstractLayer.GetPhysicalPath(file.File)); return new FileModel(file, content) { LocalPathFromRoot = localPathFromRoot, }; } We use Dictionary<string, object> as the data model, similar to how ConceptualDocumentProcessor stores the content of markdown files. Implement Save method as follows: public SaveResult Save(FileModel model) { return new SaveResult { DocumentType = \"Conceptual\", FileWithoutExtension = Path.ChangeExtension(model.File, null), }; } BuildSteps property can provide several build steps for the model. We suggest implementing this in the following manner: [ImportMany(nameof(RtfDocumentProcessor))] public IEnumerable<IDocumentBuildStep> BuildSteps { get; set; } Name property is used to display in the log, so give any constant string you like. e.g.: public string Name => nameof(RtfDocumentProcessor); Since we don't support hyperlink, keep the UpdateHref method empty. public void UpdateHref(FileModel model, IDocumentBuildContext context) { } View the final RtfDocumentProcessor.cs Create a document build step Responsibility of the build step Reconstruct documents via the Prebuild method, e.g.: remove some document according to a certain rule. Transform document content via Build method, e.g.: transform rtf content to html content. Transform more content required by all document processed via the PostBuild method, e.g.: extract the link text from the title of another document. About build order: For all documents in one processor always Prebuild -> Build -> Postbuild. For all documents in one processor always invoke Prebuild by BuildOrder. For each document in one processor always invoke Build by BuildOrder. For all documents in one processor always invoke Postbuild by BuildOrder. e.g.: Document processor X has two steps: A (with BuildOrder=1), B (with BuildOrder=2). When X is handling documents [D1, D2, D3], the invoke order is as follows: A.Prebuild([D1, D2, D3]) returns [D1, D2, D3] B.Prebuild([D1, D2, D3]) returns [D1, D2, D3] Parallel( A.Build(D1) -> B.Build(D1), A.Build(D2) -> B.Build(D2), A.Build(D3) -> B.Build(D3) ) A.Postbuild([D1, D2, D3]) B.Postbuild([D1, D2, D3]) Create our RtfBuildStep: Create a new class (RtfBuildStep.cs), and declare it is a build step for RtfDocumentProcessor: [Export(nameof(RtfDocumentProcessor), typeof(IDocumentBuildStep))] public class RtfBuildStep : IDocumentBuildStep { // todo : implements IDocumentBuildStep. } In the Build method, convert rtf to html: private readonly TaskFactory _taskFactory = new TaskFactory(new StaTaskScheduler(1)); public void Build(FileModel model, IHostService host) { string content = (string)((Dictionary<string, object>)model.Content)[\"conceptual\"]; content = _taskFactory.StartNew(() => RtfToHtmlConverter.ConvertRtfToHtml(content)).Result; ((Dictionary<string, object>)model.Content)[\"conceptual\"] = content; } Implement other methods: public int BuildOrder => 0; public string Name => nameof(RtfBuildStep); public void Postbuild(ImmutableList<FileModel> models, IHostService host) { } public IEnumerable<FileModel> Prebuild(ImmutableList<FileModel> models, IHostService host) { return models; } View the final RtfBuildStep.cs Enable plug-in Build our project. Copy the output dll files to: Global: a folder you create, named Plugins under the folder where DocFX.exe resides. Non-global: a folder you create with the name Plugins under a template folder. Then run DocFX build command with parameter -t {template}. Hint: DocFX can merge templates so create a template that only contains the Plugins folder, then run the command DocFX build with parameter -t {templateForRender},{templateForPlugins}. Build document Run command DocFX init and set the source article with **.rtf. Run command DocFX build."
  },
  "tutorial/howto_create_custom_template.html": {
    "href": "tutorial/howto_create_custom_template.html",
    "title": "How-to: Create A Custom Template | docfx",
    "keywords": "How-to: Create A Custom Template Templates are organized as a zip package or a folder. The file path (without the .zip extension) of the zip package or the path of the folder is considered to be the template name. Quickstart Let's create a template to transform Markdown files into a simple html file. Step 1. Create a template folder Create a folder for the template, for example, c:/docfx_howto/simple_template. Step 2. Add Renderer file Create a file conceptual.html.primary.tmpl under the template folder with the following content: {{{conceptual}}} Now a simple custom template is created. You may notice that DocFX reports a warning message saying that: Warning: [Build Document.Apply Templates]There is no template processing document type(s): Toc. It is because our custom template only specifies how to handle document with type conceptual. In the documentation project, run docfx build docfx.json -t c:/docfx_howto/simple_template --serve. The -t command option specifies the template name(s) used by the current build. Open http://localhost:8080 and you can see a simple web page as follows: Add Preprocessor file Step 3. Add Preprocessor file Sometimes the input data model is not exactly what Renderer wants, you may want to add some properties to the data model, or modify the data model a little bit before applying the Renderer file. This can be done by creating a Preprocessor file. Create a file conceptual.html.primary.js under the template folder with the following content: exports.transform = function (model) { model._extra_property = \"Hello world\"; return model; } Update the file conceptual.html.primary.tmpl with the following content: <h1>{{_extra_property}}</h1> {{{conceptual}}} In the documentation project, run docfx build docfx.json -t c:/docfx_howto/simple_template --serve. Open http://localhost:8080 and you can see _extra_property is added to the web page. Merge template with default template DocFX contains some embedded template resources that you can refer to directly. You can use docfx template list to list available templates provided by DocFX. Take default template as an example. Run docfx template export default. It exports what's inside default template into the folder _exported_templates. You can see that there are sets of Preprocessor and Renderer files to deal with different types of documents. DocFX supports specifying multiple templates for a documentation project. That allows you to leverage the default template for handling other types of documents, together with your custom template. When dealing with multiple templates, DocFX merges the files inside these templates. The principle for merging is: if a file name collides then the file in the latter template overwrites the one in the former template. For example, you can merge default template and your custom template by calling docfx build docfx.json -t default,c:/docfx_howto/simple_template. Multiple templates are split by a comma , in the command line. Or you can define it in docfx.json by: \"build\": { \"template\": [ \"default\", \"c:/docfx_howto/simple_template\" ] } In the documentation project, run docfx build docfx.json -t default,c:/docfx_howto/simple_template --serve. Now the warning message There is no template processing document type(s): Toc disappears because the default template contains Renderer to handle TOC files. Open http://localhost:8080/toc.html and you can see a toc web page. Tip Run docfx template export default to view what's inside the default template. Note It is possible that DocFX updates its embedded templates when a new version is released. So please make sure to re-export the template if you overwrite or are dependent on it in your custom template. Extension for Preprocessor file If you want to modify some properties based on DocFX default template's Preprocessor, you can use Preprocessor extension file to achieve this. For example, if you want to add a property to the managed reference's data model after default template's Preprocessor, you can update the file ManagedReference.extension.js in your custom template with the following content: /** * This method will be called at the start of exports.transform in ManagedReference.html.primary.js */ exports.preTransform = function (model) { return model; } /** * This method will be called at the end of exports.transform in ManagedReference.html.primary.js */ exports.postTransform = function (model) { model._extra_property = \"Hello world\"; return model; } Compared with modifying ManagedReference.html.primary.js directly, you needn't worry about merging your custom templates with DocFX's embedded templates when DocFX updates."
  },
  "tutorial/howto_filter_out_unwanted_apis_attributes.html": {
    "href": "tutorial/howto_filter_out_unwanted_apis_attributes.html",
    "title": "",
    "keywords": ""
  },
  "tutorial/intro_overwrite_files.html": {
    "href": "tutorial/intro_overwrite_files.html",
    "title": "Overwrite Files | docfx",
    "keywords": "Overwrite Files Introduction DocFX supports processing Markdown files, as well as structured data model in YAML or JSON format. We call Markdown files Conceptual Files, and the structured data model files Metadata Files. Current supported Metadata Files include: YAML files presenting managed reference model following Metadata Format for .NET Languages. Swagger JSON files presenting Swagger REST API model following Swagger Specification Version 2.0. Inside DocFX, both Conceptual Files and Metadata Files are represented as Models with different properties. Details on Model structure for these files are described in Data model inside DocFX section. DocFX introduces the concept of Overwrite File to modify or add properties to Models without changing the input Conceptual Files and Metadata Files. The format of Overwrite Files Overwrite Files are Markdown files with multiple Overwrite Sections starting with YAML header block. A valid YAML header for an Overwrite Section MUST take the form of valid YAML set between triple-dashed lines and start with property uid. Here is a basic example of an Overwrite Section: --- uid: microsoft.com/docfx/Contacts some_property: value --- Further description for `microsoft.com/docfx/Contacts` Each Overwrite Section is transformed to Overwrite Model inside DocFX. For the above example, the Overwrite Model represented in YAML format is: uid: microsoft.com/docfx/Contacts some_property: value conceptual: <p><b>Content</b> in Markdown</p> Anchor *content *content is the keyword invented and used specifically in Overwrite Files to represent the Markdown content following YAML header. We leverage Anchors syntax in YAML specification for *content. The value for *content is always transformed from Markdown content to HTML. When *content is not used, the Markdown content below YAML header will be set to conceptual property; When *content is used, the Markdown content below YAML header will no longer be set to conceptual property. With *content, we can easily add Markdown content to any properties. --- uid: microsoft.com/docfx/Contacts footer: *content --- Footer for `microsoft.com/docfx/Contacts` In the above example, the value for *content is <p>Footer for <code>microsoft.com/docfx/Contacts</code></p>, and the Overwrite Model represented in YAML format is: uid: microsoft.com/docfx/Contacts footer: <p>Footer for <code>microsoft.com/docfx/Contacts</code></p> uid for an Overwrite Model stands for the Unique IDentifier of the Model it will overwrite. So it is allowed to have multiple Overwrite Sections with YAML Header containing the same uid. For one Overwrite File, the latter Overwrite Section overwrites the former one with the same uid. For different Overwrite Files, the order of overwrite is Undetermined. So it is suggested to have Overwrite Sections with the same uid in the same Overwrite File. When processing Conceptual Files and Metadata Files, Overwrite Models with the same uid are applied to the processed Models. Different Models have different overwrite principles, Overwrite principles section describes the them in detail. Apply Overwrite Files Inside docfx.json, overwrite is used to specify the Overwrite Files. Overwrite principles As a general principle, uid is always the key that an Overwrite Model find the Model it is going to overwrite. So a Model with no uid defined will never get overwritten. Different types of files produce different Models. The quickest way to get an idea of what the Model looks like is to run: docfx build --exportRawModel --exportRawModel exports Model in JSON format with .raw.json extension. The basic principle of Overwrite Model is: It keeps the same data structure as the Model it is going to overwrite If the property is defined in Model, please refer Data model inside DocFX for the specific overwrite behavior for a specific property. If the property is not defined in Model, it is added to Model Data model inside DocFX Managed reference model Key Type Overwrite behavior uid uid Merge key. assemblies string[] Ignore. attributes Attribute[] Ignore. children uid[] Ignore. documentation Source Merge. example string[] Replace. exceptions Exception[] Merge keyed list. fullName string Replace. fullName. string Replace. id string Replace. implements uid[] Ignore. inheritance uid[] Ignore. inheritedMembers uid[] Ignore. isEii boolean Replace. isExtensionMethod boolean Replace. langs string[] Replace. modifiers. string[] Ignore. name string Replace. name. string Replace. namespace uid Replace. overridden uid Replace. parent uid Replace. platform string[] Replace. remarks markdown Replace. see LinkInfo[] Merge keyed list. seealso LinkInfo[] Merge keyed list. source Source Merge. syntax Syntax Merge. summary markdown Replace. type string Replace. Source Property Type Overwrite behavior base string Replace. content string Replace. endLine integer Replace. id string Replace. isExternal boolean Replace. href string Replace. path string Replace. remote GitSource Merge. startLine integer Replace. GitSource Property Type Overwrite behavior path string Replace. branch string Replace. repo url Replace. commit Commit Merge. key string Replace. Commit Property Type Overwrite behavior committer User Replace. author User Replace. id string Replace. message string Replace. User Property Type Overwrite behavior name string Replace. email string Replace. date datetime Replace. Exception Property Type Overwrite behavior type uid Merge key. description markdown Replace. commentId string Ignore. LinkInfo Property Type Overwrite behavior linkId uid or href Merge key. altText markdown Replace. commentId string Ignore. linkType enum(CRef or HRef) Ignore. Syntax Property Type Overwrite behavior content string Replace. content. string Replace. parameters Parameter[] Merge keyed list. typeParameters Parameter[] Merge keyed list. return Parameter Merge. Parameter Property Type Overwrite behavior id string Merge key. description markdown Replace. attributes Attribute[] Ignore. type uid Replace. Attribute Property Type Overwrite behavior arguments Argument[] Ignore. ctor uid Ignore. namedArguments NamedArgument[] Ignore. type uid Ignore. Argument Property Type Overwrite behavior type uid Ignore. value object Ignore. NamedArgument Property Type Overwrite behavior name string Ignore. type string Ignore. value object Ignore. REST API model Key Type Overwrite behavior children REST API item model Overwrite when uid of the item model matches summary string Overwrite description string Overwrite REST API item model Key Type Overwrite behavior uid string Key Conceptual model Key Type Overwrite behavior title string Overwrite rawTitle string Overwrite conceptual string Overwrite"
  },
  "tutorial/intro_rest_api_documentation.html": {
    "href": "tutorial/intro_rest_api_documentation.html",
    "title": "",
    "keywords": ""
  },
  "tutorial/intro_template.html": {
    "href": "tutorial/intro_template.html",
    "title": "Introduction to the DocFX Template System | docfx",
    "keywords": "Introduction to the DocFX Template System The DocFX template system provides a flexible way of defining and using templates to control how the final output files are rendered. These files provide the content used to publish a DocFx-generated web site. Note that this is different than the HTML templates discussed in Walkthrough Advanced: Customize Your Website, which are used to control the styling applied to the web site. As the following DocFX workflow shows, DocFX loads the set of files and transforms them into different data models using different types of Document Processors. Afterwards, the template system loads these data models, and transforms them into output files based on the document type of the data model. Each file belongs to a document type. For example, the document type for Markdown files is conceptual, and the document type for toc.md files is Toc. For a specific Template, each document type can have several Renderers. For a specific file, the template system picks the corresponding Renderers to render the input data model into output files. Renderer Renderers are files written in Mustache. It is used to transform the input data model into output files. Naming rule for a Renderer file The naming rule for a Renderer file is: <document_type>.<output_extension>[.primary].tmpl. <document_type> is the document type current Renderer responsible to. <output_extension> defines the extension of the output files going through current Renderer. For example, conceptual.html.tmpl transforms file1.md into output file file1.html, and toc.json.tmpl transforms toc.md into output file toc.json. [.primary] is optional. It is used when there are multiple Renderers with different extension for one particular document type. The output file transformed by the .primary Renderer is used as the file to be linked. The below example describes the behavior in detail. Here is an example. The following template contains two Mustache Renderer files for conceptual document type: /- some_template/ |- conceptual.html.primary.tmpl \\- conceptual.mta.json.tmpl There are two Markdown files A.md and B.md, the content for A.md is: [Link To B](B.md) The template system produces two output files for A.md: A.html and A.mta.json, and also two output files for B.md: B.html and B.mta.json. According to conceptual.html.primary.tmpl, .html is the primary output file, the link from A.md to B.md is resolved to B.html instead of B.mta.json, which is to say, the content of A.md is transformed to: <a href=\"B.html\">Link To B</a> Note If no primary Renderer is defined, DocFX randomly picks one Renderer as the primary one, and the result is unpredictable. Renderer in Mustache syntax Introduction to Mustache Mustache is a logic-less template syntax containing only tags. It works by expanding tags in a template using values provided in a hash or object. Tags are indicated by the double mustaches. {{name}} is a tag, it tries to find the name key in current context, and replace it with the value of name. mustache.5 lists the syntax of Mustache in detail. Naming rule Renderers in Mustache syntax MUST end with .tmpl extension. Mustache Partials Mustache Partials is also supported in the template system. Partials are common sections of Renderer that can be shared by multiple Renderer files. Partials MUST end with .tmpl.partial. For example, inside a Template, there is a Partial file part.tmpl.partial with content: Inside Partial {{ name }} To reuse this Partial file, Renderer file uses the following syntax: Inside Renderer {{ >part }} It has the same effect with the following Renderer file: Inside Renderer Inside Partial {{ name }} Extended syntax for Dependencies When rendering the input data model into output files, for example, html files, the html file may rely on other files to display correctly. For example, the html file dependents on stylesheet file main.css. We call such file main.css a Dependency to the Renderer. DocFX introduces the following syntax to define the dependency for the Renderer: {{!include('<file_name>')}} docfx copies these dependencies to output folder preserving its relative path to the Renderer file. Tip Mustache is logic-less, and for a specific {{name}} tag, Mustache searches its context and its parent context recursively. So most of the time Preprocessor File is used to re-define the data model used by the Mustache Renderer. Extended syntax for Master page In most cases templates with different document types share the same layout and style. For example, most of the pages can share navbar, header, or footer. DocFX introduces the following syntax to use a master page: {{!master('<master_page_name>')}} Inside the master page, the following syntax is used for pages to place their content body: {{!body}} For example, with the following master page _master.html: <html> <head></head> <body> {{!body}} <body> </html> A template conceptual.html.tmpl as follows: {{!master('_master.html')}} Hello World renders as the same as: <html> <head></head> <body> Hello World <body> </html> Preprocessor Renderers take the input data model produced by the document processor and render them into output files. Sometimes the input data model is not exactly what the Renderers want. The template system introduces the concept of Preprocessor to transform the input data model into exactly what the Renderers want. We call the data model returned by the Preprocessor the View Model. The View Model is the data model applied to the Renderers. Naming rule for Preprocessor The naming of the Preprocessor follows the naming of the Renderer, with file extension changes to .js: <renderer_file_name_without_extension>.js. If a Preprocessor has no corresponding Renderer, it still needs to be executed. For example, to run exports.getOptions function, it should be named as <document_type>.tmpl.js. Syntax for Preprocessor Preprocessors are JavaScript files following ECMAScript 5.1 standard. The template system uses Jint as JavaScript Engine, and provides several additional functions for easy debugging and integration. Module Preprocessor leverages the concept of Module as similar to the Module in Node.js. The syntax of Module in Preprocessor is a subset of the one in Node.js. The advantage of the Module concept is that the Preprocessor script file can also be run in Node.js. The Module syntax in Preprocessor is simple, To export function property from one Module file common.js: exports.util = function () {} To use the exported function property inside common.js: var common = require('./common.js'); // call util common.util(); Note Only relative path starting with ./ is supported. Log You can call the following functions to log messages with different error levels: console.log, console.warn or console.warning and console.err. Function Signature A Preprocessor file is also considered as a Module. It MUST export the function property with the signature required by DocFx's prescriptive interop pattern. There are two functions defined. Function 1: exports.getOptions Function property getOptions takes the data model produced by document processor as the input argument, and the return value must be an object with the following properties: Property Name Type Description isShared bool Defines whether the input data model can be accessed by other data models when transform. By default the value is false. If it is set to true, the data model will be stored into Globally Shared Properties. A sample exports.getOptions defined in toc.tmpl.js is: exports.getOptions = function (model) { return { isShared: true; }; } Function 2: exports.transform Function property transform takes the data model produced by document processor (described in further detail in The Input Data Model) as the input argument, and returns the View Model. View Model is the exact model to apply the corresponding Renderer. A sample exports.transform for conceptual.txt.js is: exports.transform = function (model) { model._title = \"Hello World\" return model; } If conceptual.txt.tmpl is: {{{_title}}} Then Markdown file A.md is transformed to A.txt with content: Hello World Tip For each file, the input data model can be exported to a JSON file by calling docfx build --exportRawModel. And the returned View Model can be exported to a JSON file by calling docfx build --exportViewModel. The output files are stored in the DocFx destination subdirectory, which defaults to <project-name>\\_site\\. The Input Data Model The input data model used by transform not only contains properties extracted from the content of the file, but also system generated properties and globally shared properties. System Generated Properties System generated property names start with underscore _, as listed in the following table: Name Description _rel The relative path of the root output folder from current output file. For example, if the output file is a/b/c.html from root output folder, then the value is ../../. _path The path of current output file starting from root output folder. _navPath The relative path of the root TOC file from root output folder, if exists. The root TOC file stands for the TOC file in root output folder. For example, if the output file is html file, the value is toc.html. _navRel The relative path from current output file to the root TOC file, if exists. For example, if the root TOC file is toc.html from root output folder, the value is empty. _navKey The original file path of the root TOC file starting with ~/. ~/ stands for the folder where docfx.json is in, for example, ~/toc.md. _tocPath The relative path of the TOC file that current output file belongs to from root output folder, if current output file is in that TOC file. If current output file is not defined in any TOC file, the nearest TOC file is picked. _tocRel The relative path from current output file to its TOC file. For example, if the TOC file is a/toc.html from root output folder, the value is ../. _tocKey The original file path of the TOC file starting with ~/. ~/ stands for the folder where docfx.json is in, for example, ~/a/toc.yml. Note Users can also override system generated properties by using YAML Header, fileMetadata or globalMetadata. Globally Shared Properties Globally shared properties are stored in __global key for every data model. Its initial value is read from global.json inside the Template if the file exists. If a data model has isShared equal to true with the above getOptions function property, it is stored in __global._shared with the original path starting with ~/ as the key."
  },
  "tutorial/intro_toc.html": {
    "href": "tutorial/intro_toc.html",
    "title": "",
    "keywords": ""
  },
  "tutorial/links_and_cross_references.html": {
    "href": "tutorial/links_and_cross_references.html",
    "title": "Links and Cross References | docfx",
    "keywords": "Links and Cross References Markdown provides a syntax to create hyperlinks. For example, the following syntax: [bing](http://www.bing.com) Will render to: <a href=\"http://www.bing.com\">bing</a> Here the url in the link could be either absolute url pointing to another website (www.bing.com in the above example), or a relative url pointing to a local resource on the same server (for example, about.html). When working with large documentation project that contains multiple files, it is often needed to link to another Markdown file using the relative path in the source directory. Markdown spec doesn't have a clear definition of how this should be supported. What's more, there is also a common need to link to another file using a \"semantic\" name instead of its file path. This is especially common in API reference docs, for example, you may want to use System.String to link to the topic of String class, without knowing it's actually located in api/system/string.html, which is auto generated. In this document, you'll learn the functionalities DocFX provides for resolving file links and cross reference, which will help you to reference other files in an efficient way. Link to a file using relative path In DocFX, you can link to a file using its relative path in the source directory. For example, You have a file1.md under root and a file2.md under subfolder/: / |- subfolder/ | \\- file2.md \\- file1.md You can use relative path to reference file2.md in file1.md: [file2](subfolder/file2.md) DocFX converts it to a relative path in output folder structure: <a href=\"subfolder/file2.html\">file2</a> You can see the source file name (.md) is replaced with output file name (.html). Note DocFX does not simply replace the file extension here (.md to .html), it also tracks the mapping between input and output files to make sure source file path will resolve to correct output path. For example, if in the above case, subfolder is renamed to subfolder2 using file mapping in docfx.json, in output html, the link url will also resolve to subfolder2/file2.html. Relative path vs. absolute path It's recommended to always use relative path to reference another file in the same project. Relative path will be resolved during build and produce build warning if the target file does not exist. Tip A file must be included in docfx.json to be processed by DocFX, so if you see a build warning about a broken link but the file actually exists in your file system, go and check whether this file is included in docfx.json. You can also use absolute path (path starts with /) to link to another file, but DocFX won't check its correctness for you and will keep it as-is in the output HTML. That means you should use the output file path as absolute path. For example, in the above case, you can also write the link as follows: [file2](/subfolder/file2.html) Sometimes you may find it's complicated to calculate relative path between two files. DocFX also supports paths that start with ~ to represent a path relative to the root directory of your project (i.e., where docfx.json is located). This kind of path will also be validated and resolved during build. For example, in the above case, you can write the following links in file2.md: [file1](~/file1.md) [file1](../file1.md) Both will resolve to ../file1.html in output html. Warning Automatic link doesn't support relative path. If you write something like <file.md>, it will be treated as an HTML tag rather than a link. Links in file includes If you use file include to include another file, the links in the included file are relative to the included file. For example, if file1.md includes file2.md: [!include[file2](subfolder/file2.md)] All links in file2.md are relative to the file2.md itself, even when it's included by file1.md. Note Please note that the file path in include syntax is handled differently than Markdown link. You can only use relative path to specify location of the included file. And DocFX doesn't require included file to be included in docfx.json. Tip Each file in docfx.json will build into an output file. But included files usually don't need to build into individual topics. So it's not recommended to include them in docfx.json. Links in inline HTML Markdown supports inline HTML. DocFX also supports to use relative path in inline HTML. Path in HTML link (<a>), image (<img>), script (<script>) and css (<link>) will also be resolved if they're relative path. Using cross reference Besides using file path to link to another file, DocFX also allows you to give a file a unique identifier so that you can reference this file using that identifier instead of its file path. This is useful in the following cases: A path to a file is long and difficult to memorize or changes frequently. API reference documentation which is usually auto generated so it's difficult to find its file path. References to files in another project without needing to know the project's file structure. The basic syntax for cross referencing a file is: <xref:id_of_another_file> This is similar to automatic link syntax in Markdown but with a xref scheme. This link will build into: <a href=\"path_of_another_file\">title_of_another_file</a> As you can see, one benefit of using cross reference is that you don't need to specify the link text and DocFX will automatically resolve it for you. Note Title is extracted from the first heading of the Markdown file. Or you can also specify title using title metadata. Define UID The unique identifier of a file in DocFX is called a UID. For a Markdown file, you can specify its UID by adding a UID metadata in the YAML header. For example, the following Markdown defines a UID \"fileA\". --- uid: fileA --- # This is fileA ... Note UID is supposed to be unique inside a project. If you define duplicate UID for two files, the resolve result is undetermined. For API reference files, UID is auto generated by mangling the API's signature. For example, the System.String class's UID is System.String. You can open a generated YAML file to lookup the value of its UID. Note Conceptual Markdown file doesn't have UID generated by default. So it cannot be cross referenced unless you give it a UID. Different syntax of cross reference Besides the auto link, we also support some other ways to use cross references: Markdown link In Markdown link, you can also use xref in link url: [link_text](xref:uid_of_another_file) This will resolve to: <a href=\"path_of_another_file\">link_text</a> In this case, DocFX won't resolve the link text for you because you already specified it, unless the link_text is empty. Shorthand form You can also use @uid_to_another_file to quickly reference another file. There are some rules for DocFX to determine whether a string following @ are UID: The string after @ must start with [A-Za-z], and end with: Whitespace or line end Punctuation ([.,;:!?`~]) followed by whitespace or line end Two or more punctuations ([.,;:!?`~]) A string enclosed by a pair of quotes (' or \") The render result of @ form is same as the auto link form. For example, @System.String is the same as <xref:System.String>. Warning Since @ is a common character in a document, DocFX doesn't show a warning if a UID isn't found for a shorthand form xref link. Warnings for missing links are shown for auto links and Markdown links. Using hashtag in cross reference Sometimes you need to link to the middle of a file (an anchor) rather than jump to the beginning of a file. DocFX also allows you to do that. In Markdown link or auto link, you can add a hashtag (#) followed by the anchor name after UID. For example: <xref:uid_to_file#anchor_name> [link_text](xref:uid_to_file#anchor_name) @uid_to_file#anchor_name Will all resolve to url_to_file#anchor_name in output HTML. The link text still resolves to the title of the whole file. If it's not what you need, you can specify your own link text. Note Hashtag in xref is always treated as separator between file name and anchor name. That means if you have # in UID, it has to be encoded to %23. The xref format follows the URI standard so that all reserved characters should be encoded. Link to overwrite files Overwrite file itself doesn't build into individual output file. It's merged with the API reference item model to build into a single file. If you want to link to the content inside an overwrite file (for example, an anchor), you cannot use the path to the overwrite file. Instead, you should either cross reference its UID, or link to the YAML file that contains the API. For example, you have String class which is generated from system.string.yml, then you have a string.md that overwrites its conceptual part which contains a compare-strings section. You can use one of the following syntax to link to this section: [compare strings](xref:System.String#compare-strings) [compare strings](system.string.yml#compare-strings) Both will render to: <a href=\"system.string.html#compare-strings\">compare strings</a> Cross reference between projects Another common need is to reference topics from an external project. For example, when you're writing the documentation for your own .NET library, you'll want to add some links that point to types in .NET base class library. DocFX gives you two ways to achieve this functionality: by exporting all UIDs in a project into a map file to be imported in another project, and through cross reference services. Cross reference map file When building a DocFX project, there will be an xrefmap.yml generated under output folder. This file contains information for all topics that have UID defined and their corresponding urls. The format of xrefmap.yml looks like this: references: - uid: uid_of_topic name: title_of_topic href: url_of_topic.html fullName: full_title_of_topic - ... It's a YAML object that contains following properties: references: a list of topic information, each item contains following properties: uid: UID to a conceptual topic or API reference name: title of the topic href: url to the topic, which is an absolute url or relative path to current file (xrefmap.yml) fullName: doesn't apply to conceptual, means the fully qualified name of API. For example, for String class, its name is String and fully qualified name is System.String. This property is not used in link title resolve for now but reserved for future use. Tip The topic is not necessarily a file, it can also be a section inside a file. For example, a method in a class. In this case its url could be an anchor in a file. Using cross reference map Once you import a cross reference map file in your DocFX project, all UIDs defined in that file can be cross referenced. To use a cross reference map, add a xref config to the build section of docfx.json: { \"build\": { \"xref\": [ \"<path_to_xrefmap>\" ], ... } } The value of xref could be a string or a list of strings that contain the path/url to cross reference maps. Note DocFX supports reading cross reference map from a local file or a web location. It's recommended to deploy xrefmap.yml to the website together with topic files so that others can directly use its url in docfx.json instead of downloading it to local. Cross reference services Cross reference services are hosted services that can be queried for cross reference information. When DocFX generates the metadata for your project, it will perform cross reference lookups against the service. To use a cross reference service, add a xrefservice config to the build section of docfx.json: { \"build\": { \"xrefService\": [ \"<url_to_xrefservice>\" ], ... } } For example, the URL for the cross reference service for .NET BCL types is https://xref.docs.microsoft.com/query?uid={uid}. Advanced: more options for cross reference You can create a cross link with following options: text: the display text when the cross reference has been resolved correctly. e.g.: @\"System.String?text=string\" will be resolved as string. alt: the display text when the cross reference does not have a href property. e.g.: <xref href=\"System.Collections.Immutable.ImmutableArray`1?alt=ImmutableArray\"/> will be resolved as ImmutableArray<T>. displayProperty: the property of display text when the cross reference is has resolved correctly. e.g.: <a href=\"xref:System.String?displayProperty=fullName\"/> will be resolved as System.String. altProperty: the property of display text when the cross reference does not have a href property. e.g.: <xref href=\"System.Collections.Immutable.ImmutableArray`1\" altProperty=\"name\"/> will be resolved as ImmutableArray<T>. title: the title of link. e.g.: [](xref:System.String?title=String+Class) will be resolved as String."
  },
  "tutorial/universalreference/gen_doc_for_js.html": {
    "href": "tutorial/universalreference/gen_doc_for_js.html",
    "title": "Generate API Documentation for JavaScript | docfx",
    "keywords": "Generate API Documentation for JavaScript 1. Prerequisite DocFX Node.js (includes npm) 2. Steps 2.1 Prepare Source Code Prepare the JavaScript source code for generating document. In this tutorial, we take azure-batch as an example npm install azure-batch 2.2 Generate Metadata We use Node2DocFX tool to generate YAML files. npm install node2docfx Create the node2docfx.json for the tool configuration: { \"source\": { \"include\": [\"node_modules/azure-batch/lib\"] }, \"destination\": \"yml\" } With this config, the tool will read source code under node_modules/azure-batch/lib, and extract metadata to YAML files under yml folder: node node_modules/node2docfx/node2docfx.js node2docfx.json 2.3 Build Document Create the configuration docfx.json for DocFX: { \"build\": { \"content\": [ { \"files\": [\"**/*.yml\"], \"src\": \"yml\", \"dest\": \"api\" } ], \"dest\": \"_site\" } } More information about docfx.json can be found in user manual. Run: docfx docfx.json --serve Now you can see your generated pages: http://localhost:8080/api/Account.html"
  },
  "tutorial/universalreference/gen_doc_for_ts.html": {
    "href": "tutorial/universalreference/gen_doc_for_ts.html",
    "title": "Generate API Documentation for TypeScript | docfx",
    "keywords": "Generate API Documentation for TypeScript 1. Prerequisite DocFX Node.js (includes npm) Git 2. Steps 2.1 Prepare Source Code Prepare the TypeScript source code for generating document. In this tutorial, we take azure-iot-device as an example. git clone https://github.com/Azure/azure-iot-sdk-node.git 2.2 Generate Metadata for a package We use typedoc tool and type2docfx to generate YAML files. First, let's install the tools globally. npm install -g typedoc type2docfx@0.10.5 2.2.1 TypeDoc to parse source code into a JSON format output Go to the folder where package.json file locate. Run typedoc --json api.json azure-iot-sdk-node/device/core/src --module commonjs --includeDeclarations --ignoreCompilerErrors --excludeExternals The parameter may differ for your needs. You can use typedoc -h to explore more options. 2.2.2 Type2docfx to extract the JSON format output into YAML files Find the output api.json file and run: type2docfx api.json yml The yml stands for the output folder, you can specify the folder as the content publishing folder in Section 2.3. And you can explore more option by type2docfx -h. With --sourceUrl, --sourceBranch, and --basePath parameters, you can generate yaml files referencing to the source code in Github, which will help developer to find the corresponding source code easily. Note All sources under node_modules path will be automatically ignored. 2.3 Build Document Create the configuration docfx.json for DocFX: { \"build\": { \"content\": [ { \"files\": [\"**/*.yml\"], \"src\": \"yml\", \"dest\": \"api\" } ], \"dest\": \"_site\" } } More information about docfx.json can be found in user manual. Run: docfx docfx.json --serve Now you can see your generated pages: http://localhost:8080/api/azure-iot-device/Client.html#azure_iot_device_Client 3. Know issues Some types can't link to the property correctly now. They displays in plain text and prefixed with @."
  },
  "tutorial/universalreference/intro_multiple_langs_support.html": {
    "href": "tutorial/universalreference/intro_multiple_langs_support.html",
    "title": "Introduction to Multiple Languages Support | docfx",
    "keywords": "Introduction to Multiple Languages Support 1. Introduction DocFX supports generating API documentation for C# and VB natively. However, it's not limited to these. DocFX is designed to support any language. When generating documents for a language, two steps are required: generating metadata and building documents from the metadata. 2. Workflow 2.1 Generate Metadata As different programming language has different tool written with different language to generate API documentation, this step is not included in DocFX core. We call the tool used as Metadata Tool. As UniversalReferenceDocumentProcessor is used to process these metadata files, the metadata tool should generate files according the processor's input schema. The files should: be in YAML format and end with .yml or .yaml have YamlMime ### YamlMime:UniversalReference as the first line conform to the data model defined for UniversalReference Usually, a TOC should be generated along with YAML files for easy navigation among files. 2.2 Build Document The YAML files generated are used as input to DocFX. DocFX will build these YAML files into HTML pages. 3. Supported Languages JavaScript TypeScript Python (coming soon ...)"
  },
  "tutorial/walkthrough/advanced_walkthrough.html": {
    "href": "tutorial/walkthrough/advanced_walkthrough.html",
    "title": "",
    "keywords": ""
  },
  "tutorial/walkthrough/walkthrough_create_a_docfx_project_2.html": {
    "href": "tutorial/walkthrough/walkthrough_create_a_docfx_project_2.html",
    "title": "",
    "keywords": ""
  },
  "tutorial/walkthrough/walkthrough_create_a_docfx_project.html": {
    "href": "tutorial/walkthrough/walkthrough_create_a_docfx_project.html",
    "title": "",
    "keywords": ""
  },
  "tutorial/walkthrough/walkthrough_generate_pdf.html": {
    "href": "tutorial/walkthrough/walkthrough_generate_pdf.html",
    "title": "",
    "keywords": ""
  },
  "tutorial/walkthrough/walkthrough_overview.html": {
    "href": "tutorial/walkthrough/walkthrough_overview.html",
    "title": "",
    "keywords": ""
  }
}